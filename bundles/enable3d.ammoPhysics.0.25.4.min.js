!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE")):t.ENABLE3D=e(t.THREE)}(self,(t=>(()=>{"use strict";var e={824:e=>{e.exports=t},70:function(t,e,s){var i=this&&this.__spreadArray||function(t,e){for(var s=0,i=e.length,o=t.length;s<i;s++,o++)t[o]=e[s];return t};Object.defineProperty(e,"__esModule",{value:!0}),e.Events=void 0;var o=s(822),n=function(t,e,s){void 0===s&&(s=!1),this.fn=t,this.context=e,this.once=s},r=function(t,e,s,i,o){if("function"!=typeof s)throw new TypeError("The listener must be a function");var r=new n(s,i||t,o);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),r]):t._events.get(e).push(r):(t._events.set(e,r),t._eventsCount++),t},a=function(t,e){0==--t._eventsCount?t._events=new Map:t._events.delete(e)},l=function(){function t(){this._events=new Map,this._eventsCount=0}return Object.defineProperty(t,"VERSION",{get:function(){return o.VERSION},enumerable:!1,configurable:!0}),t.prototype.eventNames=function(){return Array.from(this._events.keys())},t.prototype.listeners=function(t){var e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,i=e.length,o=new Array(i);s<i;s++)o[s]=e[s].fn;return o},t.prototype.listenerCount=function(t){var e=this._events.get(t);return e?e.fn?1:e.length:0},t.prototype.emit=function(t){for(var e,s,o=[],n=1;n<arguments.length;n++)o[n-1]=arguments[n];if(!this._events.has(t))return!1;var r,a=this._events.get(t);if(a.fn)return a.once&&this.removeListener(t,a.fn,void 0,!0),(e=a.fn).call.apply(e,i([a.context],o)),!0;var l=a.length;for(r=0;r<l;r++)a[r].once&&this.removeListener(t,a[r].fn,void 0,!0),(s=a[r].fn).call.apply(s,i([a[r].context],o));return!0},t.prototype.on=function(t,e,s){return r(this,t,e,s,!1)},t.prototype.once=function(t,e,s){return r(this,t,e,s,!0)},t.prototype.removeListener=function(t,e,s,i){if(!this._events.has(t))return this;if(!e)return a(this,t),this;var o=this._events.get(t);if(o.fn)o.fn!==e||i&&!o.once||s&&o.context!==s||a(this,t);else{for(var n=0,r=[],l=o.length;n<l;n++)(o[n].fn!==e||i&&!o[n].once||s&&o[n].context!==s)&&r.push(o[n]);r.length?this._events.set(t,1===r.length?r[0]:r):a(this,t)}return this},t.prototype.removeAllListeners=function(t){return t?this._events.delete(t)&&a(this,t):(this._events=new Map,this._eventsCount=0),this},Object.defineProperty(t.prototype,"off",{get:function(){return this.removeListener},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"addListener",{get:function(){return this.on},enumerable:!1,configurable:!0}),t}();e.Events=l},822:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VERSION=void 0,e.VERSION="0.0.5"},118:function(t,e,s){var i=this&&this.__spreadArray||function(t,e){for(var s=0,i=e.length,o=t.length;s<i;s++,o++)t[o]=e[s];return t};Object.defineProperty(e,"__esModule",{value:!0}),e.Events=void 0;var o=s(939),n=function(t,e,s){void 0===s&&(s=!1),this.fn=t,this.context=e,this.once=s},r=function(t,e,s,i,o){if("function"!=typeof s)throw new TypeError("The listener must be a function");var r=new n(s,i||t,o);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),r]):t._events.get(e).push(r):(t._events.set(e,r),t._eventsCount++),t},a=function(t,e){0==--t._eventsCount?t._events=new Map:t._events.delete(e)},l=function(){function t(){this._events=new Map,this._eventsCount=0}return Object.defineProperty(t,"VERSION",{get:function(){return o.VERSION},enumerable:!1,configurable:!0}),t.prototype.eventNames=function(){return Array.from(this._events.keys())},t.prototype.listeners=function(t){var e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,i=e.length,o=new Array(i);s<i;s++)o[s]=e[s].fn;return o},t.prototype.listenerCount=function(t){var e=this._events.get(t);return e?e.fn?1:e.length:0},t.prototype.emit=function(t){for(var e,s,o=[],n=1;n<arguments.length;n++)o[n-1]=arguments[n];if(!this._events.has(t))return!1;var r,a=this._events.get(t);if(a.fn)return a.once&&this.removeListener(t,a.fn,void 0,!0),(e=a.fn).call.apply(e,i([a.context],o)),!0;var l=a.length;for(r=0;r<l;r++)a[r].once&&this.removeListener(t,a[r].fn,void 0,!0),(s=a[r].fn).call.apply(s,i([a[r].context],o));return!0},t.prototype.on=function(t,e,s){return r(this,t,e,s,!1)},t.prototype.once=function(t,e,s){return r(this,t,e,s,!0)},t.prototype.removeListener=function(t,e,s,i){if(!this._events.has(t))return this;if(!e)return a(this,t),this;var o=this._events.get(t);if(o.fn)o.fn!==e||i&&!o.once||s&&o.context!==s||a(this,t);else{for(var n=0,r=[],l=o.length;n<l;n++)(o[n].fn!==e||i&&!o[n].once||s&&o[n].context!==s)&&r.push(o[n]);r.length?this._events.set(t,1===r.length?r[0]:r):a(this,t)}return this},t.prototype.removeAllListeners=function(t){return t?this._events.delete(t)&&a(this,t):(this._events=new Map,this._eventsCount=0),this},Object.defineProperty(t.prototype,"off",{get:function(){return this.removeListener},enumerable:!1,configurable:!0}),Object.defineProperty(t.prototype,"addListener",{get:function(){return this.on},enumerable:!1,configurable:!0}),t}();e.Events=l},939:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.VERSION=void 0,e.VERSION="0.0.5"}},s={};function i(t){var o=s[t];if(void 0!==o)return o.exports;var n=s[t]={exports:{}};return e[t].call(n.exports,n,n.exports,i),n.exports}i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};return(()=>{i.r(o),i.d(o,{AllHitsRaycaster:()=>it,AmmoPhysics:()=>nt,Clock:()=>ot,ClosestRaycaster:()=>st,ExtendedGroup:()=>c,ExtendedMesh:()=>h,ExtendedObject3D:()=>l,PhysicsLoader:()=>J,Types:()=>t});var t={};i.r(t);const e=new Map,s=(t,s=!1)=>{if(e.has(t)){const s=e.get(t);if(void 0===s)return;if(s>=5)return;e.set(t,s+1)}else e.set(t,1);s?console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55"):console.warn(`%c [enable3d] ${t} `,"background: #222; color: #bada55")};var n=i(118),r=i(824);const a=class{constructor(t,e){this.physics=t,this.ammo=e,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.impact=[],this.breakable=!1,this.fractureImpulse=1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new r.Euler,this.tmpQuaternion=new r.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new n.Events,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new n.Events)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",(()=>{t()})):this.eventEmitter.on("update",(()=>{t()}))}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",(e=>{const{bodies:s,event:i}=e;s[0].name===this.name?t(s[1],i):s[1].name===this.name&&t(s[0],i)}))}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,s){const i=this.tmpEuler.set(t,e,s),o=this.tmpQuaternion.set(0,0,0,1);o.setFromEuler(i),this.tmpBtQuaternion.setValue(0,0,0,1);const n=this.tmpBtQuaternion;n.setValue(o.x,o.y,o.z,o.w);this.physics.worldTransform.setRotation(n)}get rotation(){let t,e,s;const i=this.physics.worldTransform.getRotation();let o=this.tmpQuaternion.set(i.x(),i.y(),i.z(),i.w());o.w>1&&(o=o.normalize());const n=2*Math.acos(o.w),r=Math.sqrt(1-o.w*o.w);return r<.001?(t=o.x,e=o.y,s=o.z):(t=o.x/r,e=o.y/r,s=o.z/r),{x:t*n,y:e*n,z:s*n}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(t,e,s){this.physics.worldTransform.getOrigin().setValue(t,e,s)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,e){this.ammo.setDamping(t,e)}setGravity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}};class l extends r.Object3D{constructor(){super(),this.isExtendedObject3D=!0,this.isGroup=!1,this.vector3=new r.Vector3,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this._currentAnimation="",this._animationActions=new Map,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new r.AnimationMixer(this)),this._animationMixer}get anims(){return{current:this._currentAnimation,add:(t,e)=>this._animsAdd(t,e),get:t=>this._animsGet(t),play:(t,e=500,s=!0)=>this._animsPlay(t,e,s),mixer:this.animationMixer}}get animation(){return s('Please use "anims" instead of "animation"'),this.anims}_animsAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}_animsGet(t){const e=this._animationActions.get(t);return e||s(`Animation(${t}) not found!`),e}_animsPlay(t,e=500,s=!0){const i=this._animationActions.get(t),o=this._animationActions.get(this._currentAnimation);i&&(i.reset(),o&&(i.crossFadeFrom(o,e/1e3,!0),i.clampWhenFinished=!0),s||i.setLoop(r.LoopOnce,0),i.play()),this._currentAnimation=t}setAction(t){s(`setAction(${t}) is deprecated. Use animation.play(${t}) instead!`)}traverse(t){super.traverse(t)}traverseVisible(t){super.traverseVisible(t)}traverseAncestors(t){super.traverseAncestors(t)}}class h extends r.Mesh{constructor(t,e){super(t,e),this.isExtendedMesh=!0,this.isGroup=!1,this.vector3=new r.Vector3,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class c extends r.Group{constructor(){super(),this.isExtendedGroup=!0,this.isMesh=!1,this.hasBody=!1,this.fragmentDepth=0,this.breakable=!1,this.fractureImpulse=1,this.name=`object-${this.id}`}}const m=class{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const s=this.factory.add.plane(t,e);return this.addExisting(s,t),s}addSphere(t={},e={}){const s=this.factory.add.sphere(t,e);return this.addExisting(s,t),s}addBox(t={},e={}){const s=this.factory.add.box(t,e);return this.addExisting(s,t),s}addGround(t,e={}){const s=this.factory.add.ground(t,e),i=Object.assign(Object.assign({},t),{mass:0,collisionFlags:1});return this.addExisting(s,i),s}addCapsule(t={},e={}){const s=this.factory.add.capsule(t,e);return this.addExisting(s,t),s}addCylinder(t={},e={}){const s=this.factory.add.cylinder(t,e);return this.addExisting(s,t),s}addCone(t={},e={}){const s=this.factory.add.cone(t,e);return this.addExisting(s,t),s}addTorus(t={},e={}){const s=this.factory.add.torus(t,e);return this.addExisting(s,t),s}addExtrude(t,e={}){const s=this.factory.add.extrude(t,e);return s.translateX(1),this.addExisting(s),s}};class d{constructor(t,e){this.worldTransform=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==(null==t?void 0:t.x)?t.x:e,void 0!==(null==t?void 0:t.y)?t.y:e,void 0!==(null==t?void 0:t.z)?t.z:e)}get addConstraints(){return{lock:(t,e,s)=>this.lock(t,e,s),fixed:(t,e,s)=>this.fixed(t,e,s),pointToPoint:(t,e,s,i)=>this.pointToPoint(t,e,s,i),hinge:(t,e,s,i)=>this.hinge(t,e,s,i),slider:(t,e,s={},i)=>this.slider(t,e,s,i),spring:(t,e,s={},i)=>this.spring(t,e,s,i),coneTwist:(t,e,s={frameA:{},frameB:{}},i)=>this.coneTwist(t,e,s,i),dof:(t,e,s,i)=>this.dof(t,e,s,i)}}getTransform(t,e,s={x:0,y:0,z:0},i=!1){s=Object.assign({x:0,y:0,z:0},s);const o=new Ammo.btTransform;if(o.setIdentity(),i){const i=(n=t.getWorldTransform().getOrigin(),r=e.getWorldTransform().getOrigin(),a=(n.x()-r.x())/2+s.x,l=(n.y()-r.y())/2+s.y,h=(n.z()-r.z())/2+s.z,new Ammo.btVector3(a,l,h)),o=new Ammo.btTransform;o.setIdentity(),o.setOrigin(i);const c=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return c.op_mul(o),{transformA:c,transformB:o}}o.setOrigin(new Ammo.btVector3(s.x,s.y,s.z));return{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(o),transformB:o};var n,r,a,l,h}lock(t,e,s=!0){const i={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:i,angularUpperLimit:i},s)}fixed(t,e,s=!0){const i=this.getTransform(t.ammo,e.ammo);i.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),i.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const o=new Ammo.btFixedConstraint(t.ammo,e.ammo,i.transformA,i.transformB);return this.physicsWorld.addConstraint(o,s),o}pointToPoint(t,e,s={},i=!0){const{pivotA:o,pivotB:n}=s,r=new Ammo.btVector3((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0),a=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),l=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,r,a);return this.physicsWorld.addConstraint(l,i),l}hinge(t,e,s={},i=!0){const{pivotA:o,pivotB:n,axisA:r,axisB:a}=s,l=new Ammo.btVector3((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0),h=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),c=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),m=new Ammo.btVector3((null==a?void 0:a.x)||0,(null==a?void 0:a.y)||0,(null==a?void 0:a.z)||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,l,h,c,m,!0);return this.physicsWorld.addConstraint(d,i),d}slider(t,e,s={},i=!0){const o=this.getTransform(t.ammo,e.ammo),{frameA:n={},frameB:r={},linearLowerLimit:a=0,linearUpperLimit:l=0,angularLowerLimit:h=0,angularUpperLimit:c=0}=s,m=o.transformA.getRotation();m.setEulerZYX(n.x||0,n.y||0,n.z||0),o.transformA.setRotation(m);const d=o.transformB.getRotation();d.setEulerZYX(r.x||0,r.y||0,r.z||0),o.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,o.transformA,o.transformB,!0);return u.setLowerLinLimit(a),u.setUpperLinLimit(l),u.setLowerAngLimit(h),u.setUpperAngLimit(c),this.physicsWorld.addConstraint(u,i),u}spring(t,e,s={},i=!0){const{stiffness:o=50,damping:n=.01,angularLock:r=!1,linearLowerLimit:a={},linearUpperLimit:l={},angularLowerLimit:h={},angularUpperLimit:c={},offset:m={},center:d=!1,enableSpring:u=!0}=s,p=Object.assign({x:0,y:0,z:0},m),y=this.getTransform(t.ammo,e.ammo,p,d),g=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),g.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(l.x||0,l.y||0,l.z||0),g.setLinearUpperLimit(this.tmpBtVector3),r?(this.tmpBtVector3.setValue(0,0,0),g.setAngularLowerLimit(this.tmpBtVector3),g.setAngularUpperLimit(this.tmpBtVector3)):(console.log(h,c),g.setAngularLowerLimit(this.toAmmoV3(h,-Math.PI)),g.setAngularUpperLimit(this.toAmmoV3(c,Math.PI)));for(let t=0;t<3;t++)g.enableSpring(t,u),g.setStiffness(t,o),g.setDamping(t,n);return this.physicsWorld.addConstraint(g,i),g}coneTwist(t,e,s,i=!0){const{frameA:o,frameB:n}=s,r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue((null==o?void 0:o.x)||0,(null==o?void 0:o.y)||0,(null==o?void 0:o.z)||0);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0);this.getTransform(t.ammo,e.ammo);const l=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,r,a);return l.setAngularOnly(!0),this.physicsWorld.addConstraint(l,i),l}dof(t,e,s={},i=!0){const{offset:o,center:n=!1}=s,r=Object.assign({x:0,y:0,z:0},o),a=this.getTransform(t.ammo,e.ammo,r,n),l=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,a.transformA,a.transformB,!0),{linearLowerLimit:h,linearUpperLimit:c,angularLowerLimit:m,angularUpperLimit:d}=s,u=this.toAmmoV3(h),p=this.toAmmoV3(c),y=this.toAmmoV3(m,-Math.PI),g=this.toAmmoV3(d,Math.PI);return l.setLinearLowerLimit(u),l.setLinearUpperLimit(p),l.setAngularLowerLimit(y),l.setAngularUpperLimit(g),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),Ammo.destroy(g),this.physicsWorld.addConstraint(l,i),l}}var u=i(70);const p="hull",y="hacd",g="vhacd",f="mesh",b="all",v="manual",w=function(){const t=new r.Vector3,e=new r.Vector3,s=new r.Matrix4;return function(i,o,n,r={}){if(r.type=p,_(r),r.fit===v)return console.warn("cannot use fit: manual with type: hull"),null;const a=T(i,o),l=new Ammo.btVector3,h=new Ammo.btConvexHullShape;h.setMargin(r.margin),e.addVectors(a.max,a.min).multiplyScalar(.5);let c=0;for(let t=0;t<i.length;t++)c+=i[t].length/3;const m=r.hullMaxVertices||1e5;c>m&&console.warn(`too many vertices for hull shape; sampling ~${m} from ~${c} vertices`);const d=Math.min(1,m/c);for(let n=0;n<i.length;n++){const r=i[n];s.fromArray(o[n]);for(let o=0;o<r.length;o+=3){const a=n===i.length-1&&o===r.length-3;(Math.random()<=d||a)&&(t.set(r[o],r[o+1],r[o+2]).applyMatrix4(s).sub(e),l.setValue(t.x,t.y,t.z),h.addPoint(l,a))}}let u=h;if(h.getNumVertices()>=100){const t=new Ammo.btShapeHull(h);t.buildHull(r.margin),Ammo.destroy(h),u=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(l),C(u,r,P(n,r)),u}}(),x=function(){const t=new r.Vector3,e=new r.Vector3,s=new r.Matrix4;return function(i,o,n,r,a={}){if(a.type=y,_(a),a.fit===v)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=T(i,o),h=P(r,a);let c=0,m=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<i.length;t++)c+=i[t].length/3,n&&n[t]?m+=n[t].length/3:m+=i[t].length/9;const d=new Ammo.HACD;a.hasOwnProperty("compacityWeight")&&d.SetCompacityWeight(a.compacityWeight),a.hasOwnProperty("volumeWeight")&&d.SetVolumeWeight(a.volumeWeight),a.hasOwnProperty("nClusters")&&d.SetNClusters(a.nClusters),a.hasOwnProperty("nVerticesPerCH")&&d.SetNVerticesPerCH(a.nVerticesPerCH),a.hasOwnProperty("concavity")&&d.SetConcavity(a.concavity);const u=Ammo._malloc(3*c*8),p=Ammo._malloc(3*m*4);d.SetPoints(u),d.SetTriangles(p),d.SetNPoints(c),d.SetNTriangles(m);let g=u/8,f=p/4;for(let r=0;r<i.length;r++){const a=i[r];s.fromArray(o[r]);for(let i=0;i<a.length;i+=3)t.set(a[i+0],a[i+1],a[i+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[g+0]=t.x,Ammo.HEAPF64[g+1]=t.y,Ammo.HEAPF64[g+2]=t.z,g+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[f]=t[e],f++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[f]=t,f++}d.Compute(),Ammo._free(u),Ammo._free(p);const b=d.GetNClusters(),w=[];for(let t=0;t<b;t++){const e=new Ammo.btConvexHullShape;e.setMargin(a.margin);const s=d.GetNPointsCH(t),i=d.GetNTrianglesCH(t),o=Ammo._malloc(3*s*8),n=Ammo._malloc(3*i*4);d.GetCH(t,o,n);const r=o/8;for(let t=0;t<s;t++){const i=new Ammo.btVector3,o=Ammo.HEAPF64[r+3*t+0],n=Ammo.HEAPF64[r+3*t+1],a=Ammo.HEAPF64[r+3*t+2];i.setValue(o,n,a),e.addPoint(i,t===s-1),Ammo.destroy(i)}C(e,a,h),w.push(e)}return w}}(),V=function(){const t=new r.Vector3,e=new r.Vector3,s=new r.Matrix4;return function(i,o,n,r,a={}){if(a.type=g,_(a),a.fit===v)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=T(i,o),h=P(r,a);let c=0,m=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<i.length;t++)c+=i[t].length/3,n&&n[t]?m+=n[t].length/3:m+=i[t].length/9;const d=new Ammo.VHACD,u=new Ammo.Parameters;a.hasOwnProperty("resolution")&&u.set_m_resolution(a.resolution),a.hasOwnProperty("depth")&&u.set_m_depth(a.depth),a.hasOwnProperty("concavity")&&u.set_m_concavity(a.concavity),a.hasOwnProperty("planeDownsampling")&&u.set_m_planeDownsampling(a.planeDownsampling),a.hasOwnProperty("convexhullDownsampling")&&u.set_m_convexhullDownsampling(a.convexhullDownsampling),a.hasOwnProperty("alpha")&&u.set_m_alpha(a.alpha),a.hasOwnProperty("beta")&&u.set_m_beta(a.beta),a.hasOwnProperty("gamma")&&u.set_m_gamma(a.gamma),a.hasOwnProperty("pca")&&u.set_m_pca(a.pca),a.hasOwnProperty("mode")&&u.set_m_mode(a.mode),a.hasOwnProperty("maxNumVerticesPerCH")&&u.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH),a.hasOwnProperty("minVolumePerCH")&&u.set_m_minVolumePerCH(a.minVolumePerCH),a.hasOwnProperty("convexhullApproximation")&&u.set_m_convexhullApproximation(a.convexhullApproximation),a.hasOwnProperty("oclAcceleration")&&u.set_m_oclAcceleration(a.oclAcceleration);const p=Ammo._malloc(3*c*8+3),y=Ammo._malloc(3*m*4);let f=p/8,b=y/4;for(let r=0;r<i.length;r++){const a=i[r];s.fromArray(o[r]);for(let i=0;i<a.length;i+=3)t.set(a[i+0],a[i+1],a[i+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[f+0]=t.x,Ammo.HEAPF64[f+1]=t.y,Ammo.HEAPF64[f+2]=t.z,f+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[b]=t[e],b++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[b]=t,b++}d.Compute(p,3,c,y,3,m,u),Ammo._free(p),Ammo._free(y);const w=d.GetNConvexHulls(),x=[],V=new Ammo.ConvexHull;for(let t=0;t<w;t++){d.GetConvexHull(t,V);const e=V.get_m_nPoints(),s=(V.get_m_points(),new Ammo.btConvexHullShape);s.setMargin(a.margin);for(let t=0;t<e;t++){const i=new Ammo.btVector3,o=V.get_m_points(3*t+0),n=V.get_m_points(3*t+1),r=V.get_m_points(3*t+2);i.setValue(o,n,r),s.addPoint(i,t===e-1),Ammo.destroy(i)}C(s,a,h),x.push(s)}return Ammo.destroy(V),Ammo.destroy(d),x}}(),A=function(){const t=new r.Vector3,e=new r.Vector3,s=new r.Vector3,i=new r.Matrix4;return function(o,n,r,a,l={}){if(l.type=f,_(l),l.fit===v)return console.warn("cannot use fit: manual with type: mesh"),null;const h=P(a,l),c=new Ammo.btVector3,m=new Ammo.btVector3,d=new Ammo.btVector3,u=new Ammo.btTriangleMesh(!0,!1);for(let a=0;a<o.length;a++){const l=o[a],h=r[a]?r[a]:null;if(i.fromArray(n[a]),h)for(let o=0;o<h.length;o+=3){const n=3*h[o],r=3*h[o+1],a=3*h[o+2];t.set(l[n],l[n+1],l[n+2]).applyMatrix4(i),e.set(l[r],l[r+1],l[r+2]).applyMatrix4(i),s.set(l[a],l[a+1],l[a+2]).applyMatrix4(i),c.setValue(t.x,t.y,t.z),m.setValue(e.x,e.y,e.z),d.setValue(s.x,s.y,s.z),u.addTriangle(c,m,d,!1)}else for(let o=0;o<l.length;o+=9)t.set(l[o+0],l[o+1],l[o+2]).applyMatrix4(i),e.set(l[o+3],l[o+4],l[o+5]).applyMatrix4(i),s.set(l[o+6],l[o+7],l[o+8]).applyMatrix4(i),c.setValue(t.x,t.y,t.z),m.setValue(e.x,e.y,e.z),d.setValue(s.x,s.y,s.z),u.addTriangle(c,m,d,!1)}const p=new Ammo.btVector3(h.x,h.y,h.z);let y;return u.setScaling(p),Ammo.destroy(p),y=l.concave?new Ammo.btBvhTriangleMeshShape(u,!0,!0):new Ammo.btConvexTriangleMeshShape(u,!0),y.resources=[u],Ammo.destroy(c),Ammo.destroy(m),Ammo.destroy(d),C(y,l),y}}();function _(t){t.type=t.type||p,t.margin=t.hasOwnProperty("margin")?t.margin:.01}const C=function(t,e,s){},M=function(){const t=new r.Matrix4;return function(e,s,i){parseInt(r.REVISION)>=123?t.copy(e.matrixWorld).invert():t.getInverse(e.matrixWorld);(new r.Vector3).setFromMatrixScale(e.matrixWorld),e.traverse((o=>{const n=new r.Matrix4;o.isMesh&&(s.includeInvisible||o.el&&o.el.object3D.visible||o.visible)&&(o===e?n.identity():(o.updateWorldMatrix(!0),n.multiplyMatrices(t,o.matrixWorld)),i(o.geometry.isBufferGeometry?o.geometry.attributes.position.array:o.geometry.vertices,n.elements,o.geometry.index?o.geometry.index.array:null))}))}}(),P=function(){const t=new r.Matrix4;return function(e,s={}){const i=new r.Vector3(1,1,1);return s.fit===b&&(t.fromArray(e),i.setFromMatrixScale(t)),i}}(),T=(function(){const t=new r.Vector3}(),function(t,e){const s=new r.Box3;let i=1/0,o=1/0,n=1/0,a=-1/0,l=-1/0,h=-1/0;return s.min.set(0,0,0),s.max.set(0,0,0),B(t,e,(t=>{t.x<i&&(i=t.x),t.y<o&&(o=t.y),t.z<n&&(n=t.z),t.x>a&&(a=t.x),t.y>l&&(l=t.y),t.z>h&&(h=t.z)})),s.min.set(i,o,n),s.max.set(a,l,h),s}),B=function(){const t=new r.Vector3,e=new r.Matrix4;return function(s,i,o){for(let n=0;n<s.length;n++){e.fromArray(i[n]);for(let i=0;i<s[n].length;i+=3)t.set(s[n][i],s[n][i+1],s[n][i+2]).applyMatrix4(e),o(t)}}}();const S=class{constructor(){this._defaultMaterial=new r.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}};class E{constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new S}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),capsule:(t={},e={})=>this.makeCapsule(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),capsule:(t={},e={})=>this.addCapsule(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,s){const{x:i=0,y:o=0,z:n=0}=s;let a;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":a=new r.Line(t,e);break;case"PointsMaterial":a=new r.Points(t,e);break;default:a=new h(t,e)}return a.position.set(i,o,n),a.castShadow=a.receiveShadow=!0,a}makeExtrude(t,e){const{x:s,y:i,z:o,name:n,shape:a,autoCenter:l=!0,breakable:h=!1,...c}=t,{depth:m=1,bevelEnabled:d=!1}=c,u=new r.ExtrudeGeometry(a,{depth:m,bevelEnabled:d,...c}),p=this.addMaterial(e),y=this.createMesh(u,p,{x:s,y:i,z:o});return l&&y.geometry.center(),y.name=n||`body_id_${y.id}`,y.shape="extrude",y}addExtrude(t,e={}){const s=this.makeExtrude(t,e);return this.addExisting(s),s}makePlane(t,e){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.PlaneGeometry(l.width||1,l.height||1,l.widthSegments||1,l.heightSegments||1),c=this.addMaterial(e);c.side=r.DoubleSide;const m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="plane",m}addPlane(t,e){const s=this.makePlane(t,e);return this.addExisting(s),s}makeSphere(t,e){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.SphereGeometry(l.radius||1,l.widthSegments||16,l.heightSegments||12,l.phiStart||void 0,l.phiLength||void 0,l.thetaStart||void 0,l.thetaLength||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="sphere",m}addSphere(t={},e={}){const s=this.makeSphere(t,e);return this.addExisting(s),s}makeBox(t,e){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.BoxGeometry(l.width||1,l.height||1,l.depth||1,l.widthSegments||void 0,l.heightSegments||void 0,l.depthSegments||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="box",m}addBox(t={},e={}){const s=this.makeBox(t,e);return this.addExisting(s),s}addGround(t,e={}){const s=this.makeBox(t,e);return s.rotateX(r.MathUtils.degToRad(90)),this.addExisting(s),s}makeCapsule(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.CapsuleGeometry(l.radius||.5,l.length||1,l.capSegments||4,l.radialSegments||16),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="capsule",m}addCapsule(t={},e={}){const s=this.makeCapsule(t,e);return this.addExisting(s),s}makeCylinder(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.CylinderGeometry(l.radiusTop||1,l.radiusBottom||1,l.height||1,l.radiusSegments||void 0,l.heightSegments||void 0,l.openEnded||void 0,l.thetaStart||void 0,l.thetaLength||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="cylinder",m}addCylinder(t={},e={}){const s=this.makeCylinder(t,e);return this.addExisting(s),s}makeCone(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.ConeGeometry(l.radius||1,l.height||1,l.radiusSegments||8,l.heightSegments||1,l.openEnded||!1,l.thetaStart||0,l.thetaLength||2*Math.PI),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="cone",m}addCone(t={},e={}){const s=this.makeCone(t,e);return this.addExisting(s),s}makeTorus(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:a=!1,...l}=t,h=new r.TorusGeometry(l.radius||void 0,l.tube||void 0,l.radialSegments||void 0,l.tubularSegments||void 0,l.arc||void 0),c=this.addMaterial(e),m=this.createMesh(h,c,{x:s,y:i,z:o});return m.name=n||`body_id_${m.id}`,m.shape="torus",m}addTorus(t={},e={}){const s=this.makeTorus(t,e);return this.addExisting(s),s}addMaterial(t={}){const e=Object.keys(t)[0];let i;if("headless"===this.scene)return this.defaultMaterial.get();switch(e){case"basic":i=new r.MeshBasicMaterial(t.basic);break;case"normal":i=new r.MeshNormalMaterial(t.normal);break;case"standard":i=new r.MeshStandardMaterial(t.standard);break;case"lambert":i=new r.MeshLambertMaterial(t.lambert);break;case"phong":i=new r.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?i=new r.MeshPhysicalMaterial(t.physical):(s("You need to pass parameters to the physical material. (Fallback to default material)"),i=this.defaultMaterial.get());break;case"toon":i=new r.MeshToonMaterial(t.toon);break;case"line":i=new r.LineBasicMaterial(t.line);break;case"points":i=new r.PointsMaterial(t.points);break;case"custom":i=t.custom||this.defaultMaterial.get();break;default:i=this.defaultMaterial.get()}return i}}class O extends u.Events{addCollider(t,e,s){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",(i=>{var o,n;const{bodies:r,event:a}=i;(null===(o=r[0])||void 0===o?void 0:o.name)&&(null===(n=r[1])||void 0===n?void 0:n.name)&&(null==t?void 0:t.name)&&(null==e?void 0:e.name)&&(r[0].name===t.name&&r[1].name===e.name||r[1].name===t.name&&r[0].name===e.name)&&s(a)})))}}const k=1,z=32768;const D=class{constructor(t,e,s={}){this.scene=t,this.world=e,this.options=s,this.debugDrawMode=s.debugDrawMode||k;const i=this.debugDrawMode&z||!1,o=s.maxBufferSize||1e6;this.geometry=new r.BufferGeometry;const n=new Float32Array(3*o),a=new Float32Array(3*o);this.geometry.setAttribute("position",new r.BufferAttribute(n,3).setUsage(r.StaticDrawUsage)),this.geometry.setAttribute("color",new r.BufferAttribute(a,3).setUsage(r.StaticDrawUsage)),this.index=0;const l=new r.LineBasicMaterial({vertexColors:!0,depthTest:!i});this.mesh=new r.LineSegments(this.geometry,l),i&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,s){const i=Ammo.HEAPF32,o=i[(s+0)/4],n=i[(s+4)/4],r=i[(s+8)/4],a=i[(t+0)/4],l=i[(t+4)/4],h=i[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,l,h),this.geometry.attributes.color.setXYZ(this.index++,o,n,r);const c=i[(e+0)/4],m=i[(e+4)/4],d=i[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,c,m,d),this.geometry.attributes.color.setXYZ(this.index++,o,n,r)}drawContactPoint(t,e,s,i,o){const n=Ammo.HEAPF32,r=n[(o+0)/4],a=n[(o+4)/4],l=n[(o+8)/4],h=n[(t+0)/4],c=n[(t+4)/4],m=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,h,c,m),this.geometry.attributes.color.setXYZ(this.index++,r,a,l);const d=n[(e+0)/4]*s,u=n[(e+4)/4]*s,p=n[(e+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,h+d,c+u,m+p),this.geometry.attributes.color.setXYZ(this.index++,r,a,l)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}},j=new r.Vector3,R=new r.Line3,L=new r.Plane,F=new r.Vector3,W=new r.Triangle;class I{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new G,this.unassigned=new G,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.vertices.push(new U(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse((function(t){const s=t.geometry;if(void 0!==s){const i=s.attributes.position;if(void 0!==i)for(let s=0,o=i.count;s<o;s++){const o=new r.Vector3;o.fromBufferAttribute(i,s).applyMatrix4(t.matrixWorld),e.push(o)}}})),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let s=0,i=e.length;s<i;s++){if(e[s].distanceToPoint(t)>this.tolerance)return!1}return!0}intersectRay(t,e){const s=this.faces;let i=-1/0,o=1/0;for(let e=0,n=s.length;e<n;e++){const n=s[e],r=n.distanceToPoint(t.origin),a=n.normal.dot(t.direction);if(r>0&&a>=0)return null;const l=0!==a?-r/a:0;if(!(l<=0)&&(a>0?o=Math.min(l,o):i=Math.max(l,i),i>o))return null}return i!==-1/0?t.at(i,e):t.at(o,e),e}intersectsRay(t){return null!==this.intersectRay(t,j)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let s=t.outside;for(;null!==s.next&&s.next.face===t;)s=s.next;return this.assigned.removeSubList(e,s),e.prev=s.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const s=this.removeAllVerticesFromFace(t);if(void 0!==s)if(void 0===e)this.unassigned.appendChain(s);else{let t=s;do{const s=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=s}while(null!==t)}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{const s=e.next;let i=this.tolerance,o=null;for(let s=0;s<t.length;s++){const n=t[s];if(0===n.mark){const t=n.distanceToPoint(e.point);if(t>i&&(i=t,o=n),i>1e3*this.tolerance)break}}null!==o&&this.addVertexToFace(e,o),e=s}while(null!==e)}return this}computeExtremes(){const t=new r.Vector3,e=new r.Vector3,s=[],i=[];for(let t=0;t<3;t++)s[t]=i[t]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let o=0,n=this.vertices.length;o<n;o++){const n=this.vertices[o],r=n.point;for(let e=0;e<3;e++)r.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,r.getComponent(e)),s[e]=n);for(let t=0;t<3;t++)r.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,r.getComponent(t)),i[t]=n)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),s=e.min,i=e.max;let o=0,n=0;for(let t=0;t<3;t++){const e=i[t].point.getComponent(t)-s[t].point.getComponent(t);e>o&&(o=e,n=t)}const r=s[n],a=i[n];let l,h;o=0,R.set(r.point,a.point);for(let e=0,s=this.vertices.length;e<s;e++){const s=t[e];if(s!==r&&s!==a){R.closestPointToPoint(s.point,!0,F);const t=F.distanceToSquared(s.point);t>o&&(o=t,l=s)}}o=-1,L.setFromCoplanarPoints(r.point,a.point,l.point);for(let e=0,s=this.vertices.length;e<s;e++){const s=t[e];if(s!==r&&s!==a&&s!==l){const t=Math.abs(L.distanceToPoint(s.point));t>o&&(o=t,h=s)}}const c=[];if(L.distanceToPoint(h.point)<0){c.push(H.create(r,a,l),H.create(h,a,r),H.create(h,l,a),H.create(h,r,l));for(let t=0;t<3;t++){const e=(t+1)%3;c[t+1].getEdge(2).setTwin(c[0].getEdge(e)),c[t+1].getEdge(1).setTwin(c[e+1].getEdge(0))}}else{c.push(H.create(r,l,a),H.create(h,r,a),H.create(h,a,l),H.create(h,l,r));for(let t=0;t<3;t++){const e=(t+1)%3;c[t+1].getEdge(2).setTwin(c[0].getEdge((3-t)%3)),c[t+1].getEdge(0).setTwin(c[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(c[t]);for(let e=0,s=t.length;e<s;e++){const s=t[e];if(s!==r&&s!==a&&s!==l&&s!==h){o=this.tolerance;let t=null;for(let e=0;e<4;e++){const i=this.faces[e].distanceToPoint(s.point);i>o&&(o=i,t=this.faces[e])}null!==t&&this.addVertexToFace(s,t)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];0===s.mark&&t.push(s)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const s=this.assigned.first().face;let i=s.outside;do{const o=s.distanceToPoint(i.point);o>e&&(e=o,t=i),i=i.next}while(null!==i&&i.face===s);return t}}computeHorizon(t,e,s,i){let o;this.deleteFaceVertices(s),s.mark=1,o=null===e?e=s.getEdge(0):e.next;do{const e=o.twin,s=e.face;0===s.mark&&(s.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,e,s,i):i.push(o)),o=o.next}while(o!==e);return this}addAdjoiningFace(t,e){const s=H.create(t,e.tail(),e.head());return this.faces.push(s),s.getEdge(-1).setTwin(e.twin),s.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let s=null,i=null;for(let o=0;o<e.length;o++){const n=e[o],r=this.addAdjoiningFace(t,n);null===s?s=r:r.next.setTwin(i),this.newFaces.push(r.face),i=r}return s.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class H{constructor(){this.normal=new r.Vector3,this.midpoint=new r.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(t,e,s){const i=new H,o=new N(t,i),n=new N(e,i),r=new N(s,i);return o.next=r.prev=n,n.next=o.prev=r,r.next=n.prev=o,i.edge=o,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),s=this.edge.next.head();return W.set(t.point,e.point,s.point),W.getNormal(this.normal),W.getMidpoint(this.midpoint),this.area=W.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class N{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class U{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class G{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}class Q extends r.BufferGeometry{constructor(t=[]){super();const e=[],s=[],i=(new I).setFromPoints(t).faces;for(let t=0;t<i.length;t++){const o=i[t];let n=o.edge;do{const t=n.head().point;e.push(t.x,t.y,t.z),s.push(o.normal.x,o.normal.y,o.normal.z),n=n.next}while(n!==o.edge)}this.setAttribute("position",new r.Float32BufferAttribute(e,3)),this.setAttribute("normal",new r.Float32BufferAttribute(s,3))}}const $=t=>new(window.THREE&&window.THREE.ConvexGeometry?window.THREE.ConvexGeometry:Q)(t),q=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new r.Line3,this.tempPlane1=new r.Plane,this.tempPlane2=new r.Plane,this.tempPlane_Cut=new r.Plane,this.tempCM1=new r.Vector3,this.tempCM2=new r.Vector3,this.tempVector3=new r.Vector3,this.tempVector3_2=new r.Vector3,this.tempVector3_3=new r.Vector3,this.tempVector3_P0=new r.Vector3,this.tempVector3_P1=new r.Vector3,this.tempVector3_P2=new r.Vector3,this.tempVector3_N0=new r.Vector3,this.tempVector3_N1=new r.Vector3,this.tempVector3_AB=new r.Vector3,this.tempVector3_CB=new r.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var s=0;s<900;s++)this.segments[s]=!1};var X;q.prototype={constructor:q,prepareBreakableObject:function(t,e,s,i,o){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var n=t.userData.ammoPhysicsData;n.mass=e,n.velocity=s.clone(),n.angularVelocity=i.clone(),n.breakable=o},subdivideByImpact:function(t,e,s,i,o){var n=[],r=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,s),r.setFromCoplanarPoints(e,t.position,this.tempVector3);var l=o+i,h=this;return function o(c,m,d,u){if(Math.random()<.05*u||u>l)n.push(c);else{var p=Math.PI;0===u?(a.normal.copy(r.normal),a.constant=r.constant):u<=i?(p=(d-m)*(.2+.6*Math.random())+m,h.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,p).add(e),a.setFromCoplanarPoints(e,h.tempVector3,h.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,h.tempVector3_2.copy(e).sub(c.position).applyAxisAngle(s,p).add(c.position),h.tempVector3_3.copy(s).add(c.position),a.setFromCoplanarPoints(c.position,h.tempVector3_3,h.tempVector3_2)),h.cutByPlane(c,a,h.tempResultObjects);var y=h.tempResultObjects.object1,g=h.tempResultObjects.object2;y&&o(y,m,p,u+1),g&&o(g,p,d,u+1)}}(t,0,2*Math.PI,0),n},cutByPlane:function(t,e,i){var o=t.geometry,n=o.attributes.position.array,a=o.attributes.normal.array,l=n.length/3,h=l/3,c=o.getIndex();function m(t,e){var s=3*t+e;return c?c[s]:s}c&&(h=(c=c.array).length/3);for(var d=[],u=[],p=this.smallDelta,y=l*l,g=0;g<y;g++)this.segments[g]=!1;var f=this.tempVector3_P0,b=this.tempVector3_P1,v=this.tempVector3_N0,w=this.tempVector3_N1;for(g=0;g<h-1;g++){var x=m(g,0),V=m(g,1),A=m(g,2);v.set(a[x],a[x]+1,a[x]+2);for(var _=g+1;_<h;_++){var C=m(_,0),M=m(_,1),P=m(_,2);w.set(a[C],a[C]+1,a[C]+2),1-v.dot(w)<p&&(x===C||x===M||x===P?V===C||V===M||V===P?(this.segments[x*l+V]=!0,this.segments[V*l+x]=!0):(this.segments[A*l+x]=!0,this.segments[x*l+A]=!0):V!==C&&V!==M&&V!==P||(this.segments[A*l+V]=!0,this.segments[V*l+A]=!0))}}var T=this.tempPlane_Cut;t.updateMatrix(),q.transformPlaneToLocalSpace(e,t.matrix,T);for(g=0;g<h;g++)for(var B=m(g,0),S=m(g,1),E=m(g,2),O=0;O<3;O++){var k=0===O?B:1===O?S:E,z=0===O?S:1===O?E:B;if(!this.segments[k*l+z]){this.segments[k*l+z]=!0,this.segments[z*l+k]=!0,f.set(n[3*k],n[3*k+1],n[3*k+2]),b.set(n[3*z],n[3*z+1],n[3*z+2]);var D=0;(j=T.distanceToPoint(f))>p?(D=2,u.push(f.clone())):j<-p?(D=1,d.push(f.clone())):(D=3,d.push(f.clone()),u.push(f.clone()));var j,R=0;if((j=T.distanceToPoint(b))>p?(R=2,u.push(b.clone())):j<-p?(R=1,d.push(b.clone())):(R=3,d.push(b.clone()),u.push(b.clone())),1===D&&2===R||2===D&&1===R){this.tempLine1.start.copy(f),this.tempLine1.end.copy(b);var L=new r.Vector3;if(void 0===(L=T.intersectLine(this.tempLine1,L)))return console.error("Internal error: segment does not intersect plane."),i.segmentedObject1=null,i.segmentedObject2=null,0;d.push(L),u.push(L.clone())}}}var F=.5*t.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var W=0,I=d.length;if(I>0){for(g=0;g<I;g++)this.tempCM1.add(d[g]);this.tempCM1.divideScalar(I);for(g=0;g<I;g++){(U=d[g]).sub(this.tempCM1),W=Math.max(W,U.x,U.y,U.z)}this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);var H=0,N=u.length;if(N>0){for(g=0;g<N;g++)this.tempCM2.add(u[g]);this.tempCM2.divideScalar(N);for(g=0;g<N;g++){var U;(U=u[g]).sub(this.tempCM2),H=Math.max(H,U.x,U.y,U.z)}this.tempCM2.add(t.position)}var G=null,Q=null,X=0;if(I>4)try{(G=new r.Mesh($(d),t.material)).position.copy(this.tempCM1),G.quaternion.copy(t.quaternion),G.userData=t.userData,this.prepareBreakableObject(G,F,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*W>this.minSizeForBreak),X++}catch(t){s("Error in ConvexObjectBreaker.ts",!0),s(t,!0)}if(N>4)try{(Q=new r.Mesh($(u),t.material)).position.copy(this.tempCM2),Q.quaternion.copy(t.quaternion),Q.userData=t.userData,this.prepareBreakableObject(Q,F,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*H>this.minSizeForBreak),X++}catch(t){s("Error in ConvexObjectBreaker.ts",!0),s(t,!0)}return i.object1=G,i.object2=Q,X}},q.transformFreeVector=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[4]*i+n[8]*o,t.y=n[1]*s+n[5]*i+n[9]*o,t.z=n[2]*s+n[6]*i+n[10]*o,t},q.transformFreeVectorInverse=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[1]*i+n[2]*o,t.y=n[4]*s+n[5]*i+n[6]*o,t.z=n[8]*s+n[9]*i+n[10]*o,t},q.transformTiedVectorInverse=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[1]*i+n[2]*o-n[12],t.y=n[4]*s+n[5]*i+n[6]*o-n[13],t.z=n[8]*s+n[9]*i+n[10]*o-n[14],t},q.transformPlaneToLocalSpace=(X=new r.Vector3,function(t,e,s){s.normal.copy(t.normal),s.constant=t.constant;var i=q.transformTiedVectorInverse(t.coplanarPoint(X),e);q.transformFreeVectorInverse(s.normal,e),s.constant=-i.dot(s.normal)});const Z=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){t instanceof Error&&console.error(t.message)}return!1})(),Y=(t,e)=>{var s=document.createElement("script");s.onload=()=>{e()},s.onerror=()=>{throw new Error(`failed to load ${t}`)},s.async=!0,s.src=t,document.head.appendChild(s)},K=(t,e)=>{Y(Z?`${t}/ammo.wasm.js`:`${t}/ammo.js`,(()=>e()))},J=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),K(t,(()=>{Ammo().then((()=>{e()}))}))};const tt=function(t,e){e.forEach((e=>{Object.getOwnPropertyNames(e.prototype).forEach((s=>{Object.defineProperty(t.prototype,s,Object.getOwnPropertyDescriptor(e.prototype,s)||Object.create(null))}))}))};class et{constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,s=0){this._btRayFrom.setValue(t,e,s)}setRayToWorld(t=0,e=0,s=0){this._btRayTo.setValue(t,e,s)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class st{constructor(t){this.physics=t,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}class it{constructor(t){this.physics=t,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}tt(st,[et,class{constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){return Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody).threeObject}}]),tt(it,[et,class{constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const i=t.at(s);e.push({x:i.x(),y:i.y(),z:i.z()})}return e}getHitPointWorld(){return s("Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const i=t.at(s);e.push({x:i.x(),y:i.y(),z:i.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let s=e.size()-1;s>=0;s--){const i=Ammo.castObject(e.at(s),Ammo.btRigidBody);t.push(i.threeObject)}return t}}]);class ot{constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}class nt extends u.Events{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new r.Euler,this.tmpQuaternion=new r.Quaternion,this.tmpVector3=new r.Vector3,this.tmpVector3a=new r.Vector3,this.tmpMatrix4=new r.Matrix4,this.tmpMatrix4a=new r.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new r.Vector3,this.impactPoint=new r.Vector3,this.impactNormal=new r.Vector3,"headless"!==t&&(this.defaultMaterial=new S),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var e;const s=Object.keys(t).includes("body")?t.body:t;if(void 0===(null==s?void 0:s.ammo))return;let i=s.ammo.threeObject;const o=i.name;if(o&&i&&(null===(e=null==i?void 0:i.body)||void 0===e?void 0:e.ammo)){i.body.isSoftBody?this.physicsWorld.removeSoftBody(i.body.ammo):this.physicsWorld.removeRigidBody(i.body.ammo),i.body.destructor(),i.body=void 0,i.hasBody=!1,delete s.ammo.threeObject;for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===o&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&i&&(i=null)}setup(){if(this.worldTransform=new Ammo.btTransform,"function"==typeof this.config.setupPhysicsWorld?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new q,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new O,this.factory=new E(this.scene),this.shapes=new m(this.factory,((t,e)=>this.addExisting(t,e))),this.constraints=new d(this.worldTransform,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new D(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let s;if(!e){const t=new Ammo.btDefaultCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),i=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver;s=new Ammo.btDiscreteDynamicsWorld(e,i,o,t)}if(e){const t=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),i=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver,n=new Ammo.btDefaultSoftBodySolver;s=new Ammo.btSoftRigidDynamicsWorld(e,i,o,t,n)}return s.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),s}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=e.material,t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,t.name=`${e.name}__DEBRIS_${t.id}`,this.scene.add(t),this.addExisting(t,{autoCenter:!0}),t.body.fractureImpulse=e.body.fractureImpulse,t.body.breakable=!1,setTimeout((()=>{t.body.breakable=!0}),2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0;t<this.rigidBodies.length;t++){const e=this.rigidBodies[t];e.body.impact=[];const s=e.body.ammo.getMotionState();if(s)if(s.getWorldTransform(this.worldTransform),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),s.setWorldTransform(this.worldTransform),e.body.needUpdate=!1;else if(e.body.skipUpdate);else if(!e.body.ammo.isStaticObject()){const t=this.worldTransform.getOrigin(),s=this.worldTransform.getRotation(),i=e.body.offset;if(e.body.ignoreScale)this.tmpVector3a.set(e.scale.x,e.scale.y,e.scale.z);else{const t=e.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(t.x(),t.y(),t.z())}this.tmpVector3.set(t.x()+i.x,t.y()+i.y,t.z()+i.z),this.tmpQuaternion.set(s.x(),s.y(),s.z(),s.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),e.parent?parseInt(r.REVISION)>=123?this.tmpMatrix4a.copy(e.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(e.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(e.position,e.quaternion,e.scale)}}}detectCollisions(){var t,e;const s=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const i=this.physicsWorld.getDispatcher(),o=i.getNumManifolds();for(let n=0;n<o;n++){const o=i.getManifoldByIndexInternal(n),r=o.getNumContacts(),a=Ammo.castObject(o.getBody0(),Ammo.btRigidBody),l=Ammo.castObject(o.getBody1(),Ammo.btRigidBody),h=a.threeObject,c=l.threeObject;if(!h||!c)continue;if(""===a.name&&""===l.name)continue;const m=null===(t=h.body)||void 0===t?void 0:t.checkCollisions,d=null===(e=c.body)||void 0===e?void 0:e.checkCollisions,u=h.body.breakable,p=c.body.breakable,y=h.body.fractureImpulse,g=c.body.fractureImpulse,f=m||d,b=u||p;if(void 0===h.fragmentDepth&&(h.fragmentDepth=0),void 0===c.fragmentDepth&&(c.fragmentDepth=0),!f&&!b)continue;let v=!1,w=0,x="start";for(let t=0;t<r;t++){const e=o.getContactPoint(t);if(e.getDistance()<=0){v=!0;const t=e.getAppliedImpulse(),i=e.get_m_positionWorldOnB(),o=e.get_m_normalWorldOnB();if(m||d){const e=[h.uuid,c.uuid].sort(),n=`${e[0]}__${e[1]}`;if(this.earlierDetectedCollisions.find((t=>t.combinedName===n))&&(x="collision"),!s.find((t=>t.combinedName===n))){s.push({combinedName:n,collision:!0});const e={x:i.x(),y:i.y(),z:i.z()},r={x:o.x(),y:o.y(),z:o.z()};h.body.impact.push({impulse:t,point:e,normal:r,name:c.name}),c.body.impact.push({impulse:t,point:e,normal:r,name:h.name}),this.collisionEvents.emit("collision",{bodies:[h,c],event:x})}}t>=w&&(w=t,(u||p)&&(this.impactPoint.set(i.x(),i.y(),i.z()),this.impactNormal.set(o.x(),o.y(),o.z())));break}}if(!v)continue;if(!b)continue;const V=2;if(this.emptyV3.set(0,0,0),h.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:u,physicsBody:a},c.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:p,physicsBody:l},u&&w>y&&h.fragmentDepth<V){const t=this.convexBreaker.subdivideByImpact(h,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=a.getLinearVelocity(),i=a.getAngularVelocity(),o=t[s];o.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),o.userData.ammoPhysicsData.angularVelocity.set(i.x(),i.y(),i.z()),this.createDebrisFromBreakableObject(o,h)}this.objectsToRemove[this.numObjectsToRemove++]=h}if(p&&w>g&&c.fragmentDepth<V){const t=this.convexBreaker.subdivideByImpact(c,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=l.getLinearVelocity(),i=l.getAngularVelocity(),o=t[s];o.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),o.userData.ammoPhysicsData.angularVelocity.set(i.x(),i.y(),i.z()),this.createDebrisFromBreakableObject(o,c)}this.objectsToRemove[this.numObjectsToRemove++]=c}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach((t=>{const{combinedName:e}=t;if(!s.find((t=>t.combinedName===e))){const t=e.split("__"),s=this.rigidBodies.find((e=>e.uuid===t[0])),i=this.rigidBodies.find((e=>e.uuid===t[1])),o="end";s&&i&&this.collisionEvents.emit("collision",{bodies:[s,i],event:o})}})),this.earlierDetectedCollisions=[...s]}setGravity(t=0,e=-9.8,s=0){this.tmpBtVector3.setValue(t,e,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then((()=>{this.setup()})):this.setup():s("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,s)=>this.collisionEvents.addCollider(t,e,s),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),capsule:(t={},e={})=>this.shapes.addCapsule(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new st(this):new it(this)}}prepareThreeObjectForCollisionShape(t,e={}){var i,o;const{autoCenter:n=!1}=e,a={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let l="unknown";const h=(null===(i=t.geometry)||void 0===i?void 0:i.type)||"unknown";/box/i.test(h)?l="box":/cone/i.test(h)?l="cone":/cylinder/i.test(h)?l="cylinder":/extrude/i.test(h)?l="extrude":/plane/i.test(h)?l="plane":/sphere/i.test(h)?l="sphere":/torus/i.test(h)&&(l="torus");let c=Object.assign(Object.assign({},a),null===(o=null==t?void 0:t.geometry)||void 0===o?void 0:o.parameters);if(e.shape?(c=Object.assign(Object.assign({},a),e),l=e.shape):t.shape&&(l=t.shape),Object.keys(c).forEach((t=>{void 0===c[t]&&a[t]&&(c[t]=a[t])})),n)if(t.isMesh&&t.geometry)t.geometry.center();else if(t.isGroup){const e=new r.Box3,s=new r.Vector3;e.setFromObject(t).getCenter(s),t.traverse((t=>{t.isMesh&&t.geometry.translate(-s.x,-s.y,-s.z)}))}return"cylinder"===l&&(c.radius=e.radius||c.radiusTop),"extrude"===l&&(l="hacd"),"mesh"!==l&&"convex"!==l||(l="convexMesh"),"concave"===l&&(l="concaveMesh"),"unknown"===l&&(s(`Shape for ${null==t?void 0:t.name} not recognized! Will fallback to box.`),l="box"),{shape:l,params:c,object:t}}createCollisionShape(t,e,s){const i=(null==s?void 0:s.quaternion)?null==s?void 0:s.quaternion:new r.Quaternion(0,0,0,1),{axis:o="y"}=e,n=new Ammo.btVector3,a=null==s?void 0:s.geometry;s&&(null==a?void 0:a.isGeometry)&&(s.geometry=(new r.BufferGeometry).fromGeometry(a));let l,h={};switch(-1!==this.complexShapes.indexOf(t)&&(h=(t=>{const e=(new r.Matrix4).elements,s=[],i=[],o=[];return M(t,{},((t,e,n)=>{s.push(t),i.push(e),o.push(n)})),{vertices:s,matrices:i,indexes:o,matrixWorld:e}})(s)),t){case"box":n.setValue(e.width/2,e.height/2,e.depth/2),l=new Ammo.btBoxShape(n);break;case"sphere":l=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(o){case"y":n.setValue(e.radius,e.height/2,e.radius),l=new Ammo.btCylinderShape(n);break;case"x":n.setValue(e.height/2,e.radius,e.radius),l=new Ammo.btCylinderShapeX(n);break;case"z":n.setValue(e.radius,e.radius,e.height/2),l=new Ammo.btCylinderShapeZ(n)}break;case"cone":switch(o){case"y":l=new Ammo.btConeShape(e.radius,e.height);break;case"x":l=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":l=new Ammo.btConeShapeZ(e.radius,e.height)}break;case"capsule":switch(o){case"y":l=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":l=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":l=new Ammo.btCapsuleShapeZ(e.radius,e.height)}break;case"torus":l=((t,e)=>{const{radius:s=1,tube:i=.4,tubularSegments:o=8}=t,n=Math.PI,r=o,a=Math.sqrt(2*i*i-2*i*i*Math.cos(2*n/r)),l=new Ammo.btVector3(i,n/r+.5*a,i),h=new Ammo.btCylinderShape(l);h.setMargin(.05);const c=new Ammo.btCompoundShape,m=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,s,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<r;t++){const e=2*t*n/r,s=d.rotate(m,e),i=new Ammo.btTransform;u.setRotation(m,e+Math.PI/2),i.setIdentity(),i.setOrigin(s),i.setRotation(u),c.addChildShape(i,h)}return c})(e,i);break;case"plane":case"convexMesh":l=A(h.vertices,h.matrices,h.indexes,h.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"hull":l=w(h.vertices,h.matrices,h.matrixWorld,e);break;case"hacd":l=x(h.vertices,h.matrices,h.indexes,h.matrixWorld,e);break;case"vhacd":l=V(h.vertices,h.matrices,h.indexes,h.matrixWorld,e);break;case"concaveMesh":l=A(h.vertices,h.matrices,h.indexes,h.matrixWorld,Object.assign(Object.assign({},e),{concave:!0}))}Ammo.destroy(n);const{x:c,y:m,z:d}=e;return(c||m||d)&&(l._compoundOffset={x:c||0,y:m||0,z:d||0}),Array.isArray(l)&&(l=this.mergeCollisionShapesToCompoundShape(l)),l}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach((t=>{const{_childOffset:s,_compoundOffset:i}=t;if(s){const{pos:i,quat:o,scale:n,margin:r}=s,a=this.applyPosQuatScaleMargin(t,i,o,n,r);e.addChildShape(a,t)}else if(i){const s=new Ammo.btTransform;s.setIdentity(),s.setOrigin(new Ammo.btVector3(i.x,i.y,i.z)),e.addChildShape(s,t)}else{const s=new Ammo.btTransform;s.setIdentity(),e.addChildShape(s,t)}})),e}addExisting(t,e={}){const{hasBody:i}=t;if(i)return void s(`Object "${t.name}" already has a physical body!`);const o=new r.Vector3,n=new r.Quaternion,a=new r.Vector3;t.getWorldPosition(o),t.getWorldQuaternion(n),t.getWorldScale(a);const l="1"===(e.collisionFlags||0).toString(2).slice(-1),h="1"===(e.collisionFlags||0).toString(2).slice(-2,-1),{shape:c="unknown",compound:m=[],mass:d=(l||h?0:1),collisionFlags:u=0,collisionGroup:p=1,collisionMask:y=-1,offset:g,breakable:f=!1,addChildren:b=!0,margin:v=.01,ignoreScale:w=!1,fractureImpulse:x=1}=e;if(w&&a.set(1,1,1),m.length>=1){const e=m.map((t=>this.createCollisionShape(t.shape,t))),s=this.mergeCollisionShapesToCompoundShape(e),i=this.applyPosQuatScaleMargin(s,o,n,a,v),r=this.collisionShapeToRigidBody(s,i,d,h);return this.addRigidBodyToWorld(t,r,u,p,y,g),t.body.breakable=f,t.body.fractureImpulse=x,void(t.body.ignoreScale=w)}const V=[];if("unknown"!==c||t.isMesh){const s=this.prepareThreeObjectForCollisionShape(t,e),i=this.createCollisionShape(s.shape,s.params,s.object);V.push(i)}if("unknown"===c&&b&&t.children.length>=1&&t.children.forEach((t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),s=this.createCollisionShape(e.shape,e.params,e.object);s._childOffset={pos:t.position.clone(),quat:t.quaternion.clone(),scale:t.scale.clone(),margin:v},V.push(s)}})),0===V.length){const s=this.prepareThreeObjectForCollisionShape(t,e),i=this.createCollisionShape(s.shape,s.params,s.object);V.push(i)}const A=1===V.length?V[0]:this.mergeCollisionShapesToCompoundShape(V),_=this.applyPosQuatScaleMargin(A,o,n,a,v),C=this.collisionShapeToRigidBody(A,_,d,h);this.addRigidBodyToWorld(t,C,u,p,y,g),t.body.breakable=f,t.body.fractureImpulse=x,t.body.ignoreScale=w}addRigidBodyToWorld(t,e,s,i,o,n){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e,i,o);const r=Object.values(e)[0];t.name||(t.name=`object-${t.id}`),e.name=t.name,t.body=new a(this,e),t.hasBody=!0,t.ptr=r,e.threeObject=t,n&&(t.body.offset=Object.assign({x:0,y:0,z:0},n)),t.body.setCollisionFlags(s)}applyPosQuatScaleMargin(t,e=new r.Vector3,s=new r.Quaternion,i=new r.Vector3,o=.01){t.setMargin(o);const n=new Ammo.btQuaternion(0,0,0,1);n.setValue(s.x,s.y,s.z,s.w);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(e.x,e.y,e.z),a.setRotation(n),Ammo.destroy(n);const l=new Ammo.btVector3(i.x,i.y,i.z);return t.setLocalScaling(l),Ammo.destroy(l),a}collisionShapeToRigidBody(t,e,s,i){const o=new Ammo.btDefaultMotionState(e),n=new Ammo.btVector3(0,0,0);s>0&&t.calculateLocalInertia(s,n);const r=new Ammo.btRigidBodyConstructionInfo(s,o,t,n),a=new Ammo.btRigidBody(r);return(s>0||i)&&a.setActivationState(4),a}}})(),o})()));