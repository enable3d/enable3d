!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE")):t.ENABLE3D=e(t.THREE)}(self,(t=>(()=>{"use strict";var e={612:e=>{e.exports=t}},s={};function i(t){var o=s[t];if(void 0!==o)return o.exports;var n=s[t]={exports:{}};return e[t](n,n.exports,i),n.exports}i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var o={};i.r(o),i.d(o,{AllHitsRaycaster:()=>dt,AmmoPhysics:()=>pt,Clock:()=>ut,ClosestRaycaster:()=>ct,ExtendedGroup:()=>g,ExtendedMesh:()=>y,ExtendedObject3D:()=>p,PhysicsLoader:()=>lt,Types:()=>n});var n={};i.r(n);const r=new Map,a=(t,e=!1)=>{if(r.has(t)){const e=r.get(t);if(void 0===e)return;if(e>=5)return;r.set(t,e+1)}else r.set(t,1);e?console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55"):console.warn(`%c [enable3d] ${t} `,"background: #222; color: #bada55")};class l{fn;context;once;constructor(t,e,s=!1){this.fn=t,this.context=e,this.once=s}}const m=(t,e,s,i,o)=>{if("function"!=typeof s)throw new TypeError("The listener must be a function");const n=new l(s,i||t,o);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),n]):t._events.get(e).push(n):(t._events.set(e,n),t._eventsCount++),t},h=(t,e)=>{0==--t._eventsCount?t._events=new Map:t._events.delete(e)};class c{static get VERSION(){return"0.0.7"}_events=new Map;_eventsCount=0;eventNames(){return Array.from(this._events.keys())}listeners(t){const e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,i=e.length,o=new Array(i);s<i;s++)o[s]=e[s].fn;return o}listenerCount(t){const e=this._events.get(t);return e?e.fn?1:e.length:0}emit(t,...e){if(!this._events.has(t))return!1;const s=this._events.get(t);let i;if(s.fn)return s.once&&this.removeListener(t,s.fn,void 0,!0),s.fn.call(s.context,...e),!0;{const o=s.length;for(i=0;i<o;i++)s[i].once&&this.removeListener(t,s[i].fn,void 0,!0),s[i].fn.call(s[i].context,...e)}return!0}on(t,e,s){return m(this,t,e,s,!1)}once(t,e,s){return m(this,t,e,s,!0)}removeListener(t,e,s,i){if(!this._events.has(t))return this;if(!e)return h(this,t),this;const o=this._events.get(t);if(o.fn)o.fn!==e||i&&!o.once||s&&o.context!==s||h(this,t);else{for(var n=0,r=[],a=o.length;n<a;n++)(o[n].fn!==e||i&&!o[n].once||s&&o[n].context!==s)&&r.push(o[n]);r.length?this._events.set(t,1===r.length?r[0]:r):h(this,t)}return this}removeAllListeners(t){return t?this._events.delete(t)&&h(this,t):(this._events=new Map,this._eventsCount=0),this}get off(){return this.removeListener}get addListener(){return this.on}}var d=i(612);const u=class{physics;ammo;ptr;body;ignoreScale=!1;isSoftBody=!1;offset={x:0,y:0,z:0};name;errors=[];checkCollisions=!1;impact=[];breakable=!1;fractureImpulse=1;didUpdate=!1;skipUpdate=!1;_emitUpdateEvents=!1;_needUpdate=!1;tmpEuler=new d.Euler;tmpQuaternion=new d.Quaternion;tmpBtVector3=new Ammo.btVector3;tmpBtVector3_1=new Ammo.btVector3;tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1);eventEmitter=new c;constructor(t,e){this.physics=t,this.ammo=e,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new c)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",(()=>{t()})):this.eventEmitter.on("update",(()=>{t()}))}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",(e=>{const{bodies:s,event:i}=e;s[0].name===this.name?t(s[1],i):s[1].name===this.name&&t(s[0],i)}))}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,s){const i=this.tmpEuler.set(t,e,s),o=this.tmpQuaternion.set(0,0,0,1);o.setFromEuler(i),this.tmpBtQuaternion.setValue(0,0,0,1);const n=this.tmpBtQuaternion;n.setValue(o.x,o.y,o.z,o.w);this.physics.worldTransform.setRotation(n)}get rotation(){let t,e,s;const i=this.physics.worldTransform.getRotation();let o=this.tmpQuaternion.set(i.x(),i.y(),i.z(),i.w());o.w>1&&(o=o.normalize());const n=2*Math.acos(o.w),r=Math.sqrt(1-o.w*o.w);return r<.001?(t=o.x,e=o.y,s=o.z):(t=o.x/r,e=o.y/r,s=o.z/r),{x:t*n,y:e*n,z:s*n}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(t,e,s){this.physics.worldTransform.getOrigin().setValue(t,e,s)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,e){this.ammo.setDamping(t,e)}setGravity(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,s){this.tmpBtVector3.setValue(t,e,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}};class p extends d.Object3D{ptr;isMesh=!1;isExtendedObject3D=!0;isGroup=!1;vector3=new d.Vector3;shape;name;body;hasBody=!1;fragmentDepth=0;breakable=!1;fractureImpulse=1;children=[];parent=null;_currentAnimation="";_animationActions=new Map;_animationMixer;constructor(){super(),this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new d.AnimationMixer(this)),this._animationMixer}get anims(){return{current:this._currentAnimation,add:(t,e)=>this._animsAdd(t,e),get:t=>this._animsGet(t),play:(t,e=500,s=!0)=>this._animsPlay(t,e,s),mixer:this.animationMixer}}get animation(){return a('Please use "anims" instead of "animation"'),this.anims}_animsAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}_animsGet(t){const e=this._animationActions.get(t);return e||a(`Animation(${t}) not found!`),e}_animsPlay(t,e=500,s=!0){const i=this._animationActions.get(t),o=this._animationActions.get(this._currentAnimation);i&&(i.reset(),o&&(i.crossFadeFrom(o,e/1e3,!0),i.clampWhenFinished=!0),s||i.setLoop(d.LoopOnce,0),i.play()),this._currentAnimation=t}setAction(t){a(`setAction(${t}) is deprecated. Use animation.play(${t}) instead!`)}traverse(t){super.traverse(t)}traverseVisible(t){super.traverseVisible(t)}traverseAncestors(t){super.traverseAncestors(t)}}class y extends d.Mesh{ptr;isExtendedMesh=!0;isGroup=!1;vector3=new d.Vector3;shape;name;body;hasBody=!1;fragmentDepth=0;breakable=!1;fractureImpulse=1;constructor(t,e){super(t,e),this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}class g extends d.Group{ptr;isExtendedGroup=!0;isMesh=!1;shape;name;body;hasBody=!1;fragmentDepth=0;breakable=!1;fractureImpulse=1;constructor(){super(),this.name=`object-${this.id}`}}const f=class{factory;addExisting;constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const s=this.factory.add.plane(t,e);return this.addExisting(s,t),s}addSphere(t={},e={}){const s=this.factory.add.sphere(t,e);return this.addExisting(s,t),s}addBox(t={},e={}){const s=this.factory.add.box(t,e);return this.addExisting(s,t),s}addGround(t,e={}){const s=this.factory.add.ground(t,e),i={...t,mass:0,collisionFlags:1};return this.addExisting(s,i),s}addCapsule(t={},e={}){const s=this.factory.add.capsule(t,e);return this.addExisting(s,t),s}addCylinder(t={},e={}){const s=this.factory.add.cylinder(t,e);return this.addExisting(s,t),s}addCone(t={},e={}){const s=this.factory.add.cone(t,e);return this.addExisting(s,t),s}addTorus(t={},e={}){const s=this.factory.add.torus(t,e);return this.addExisting(s,t),s}addExtrude(t,e={}){const s=this.factory.add.extrude(t,e);return s.translateX(1),this.addExisting(s),s}};class b{worldTransform;physicsWorld;tmpBtVector3=new Ammo.btVector3;constructor(t,e){this.worldTransform=t,this.physicsWorld=e}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==t?.x?t.x:e,void 0!==t?.y?t.y:e,void 0!==t?.z?t.z:e)}get addConstraints(){return{lock:(t,e,s)=>this.lock(t,e,s),fixed:(t,e,s)=>this.fixed(t,e,s),pointToPoint:(t,e,s,i)=>this.pointToPoint(t,e,s,i),hinge:(t,e,s,i)=>this.hinge(t,e,s,i),slider:(t,e,s={},i)=>this.slider(t,e,s,i),spring:(t,e,s={},i)=>this.spring(t,e,s,i),coneTwist:(t,e,s={frameA:{},frameB:{}},i)=>this.coneTwist(t,e,s,i),dof:(t,e,s,i)=>this.dof(t,e,s,i)}}getTransform(t,e,s={x:0,y:0,z:0},i=!1){s={x:0,y:0,z:0,...s};const o=new Ammo.btTransform;if(o.setIdentity(),i){const i=(n=t.getWorldTransform().getOrigin(),r=e.getWorldTransform().getOrigin(),a=(n.x()-r.x())/2+s.x,l=(n.y()-r.y())/2+s.y,m=(n.z()-r.z())/2+s.z,new Ammo.btVector3(a,l,m)),o=new Ammo.btTransform;o.setIdentity(),o.setOrigin(i);const h=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return h.op_mul(o),{transformA:h,transformB:o}}o.setOrigin(new Ammo.btVector3(s.x,s.y,s.z));return{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(o),transformB:o};var n,r,a,l,m}lock(t,e,s=!0){const i={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:i,angularUpperLimit:i},s)}fixed(t,e,s=!0){const i=this.getTransform(t.ammo,e.ammo);i.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),i.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const o=new Ammo.btFixedConstraint(t.ammo,e.ammo,i.transformA,i.transformB);return this.physicsWorld.addConstraint(o,s),o}pointToPoint(t,e,s={},i=!0){const{pivotA:o,pivotB:n}=s,r=new Ammo.btVector3(o?.x||0,o?.y||0,o?.z||0),a=new Ammo.btVector3(n?.x||0,n?.y||0,n?.z||0),l=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,r,a);return this.physicsWorld.addConstraint(l,i),l}hinge(t,e,s={},i=!0){const{pivotA:o,pivotB:n,axisA:r,axisB:a}=s,l=new Ammo.btVector3(o?.x||0,o?.y||0,o?.z||0),m=new Ammo.btVector3(n?.x||0,n?.y||0,n?.z||0),h=new Ammo.btVector3(r?.x||0,r?.y||0,r?.z||0),c=new Ammo.btVector3(a?.x||0,a?.y||0,a?.z||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,l,m,h,c,!0);return this.physicsWorld.addConstraint(d,i),d}slider(t,e,s={},i=!0){const o=this.getTransform(t.ammo,e.ammo),{frameA:n={},frameB:r={},linearLowerLimit:a=0,linearUpperLimit:l=0,angularLowerLimit:m=0,angularUpperLimit:h=0}=s,c=o.transformA.getRotation();c.setEulerZYX(n.x||0,n.y||0,n.z||0),o.transformA.setRotation(c);const d=o.transformB.getRotation();d.setEulerZYX(r.x||0,r.y||0,r.z||0),o.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,o.transformA,o.transformB,!0);return u.setLowerLinLimit(a),u.setUpperLinLimit(l),u.setLowerAngLimit(m),u.setUpperAngLimit(h),this.physicsWorld.addConstraint(u,i),u}spring(t,e,s={},i=!0){const{stiffness:o=50,damping:n=.01,angularLock:r=!1,linearLowerLimit:a={},linearUpperLimit:l={},angularLowerLimit:m={},angularUpperLimit:h={},offset:c={},center:d=!1,enableSpring:u=!0}=s,p={x:0,y:0,z:0,...c},y=this.getTransform(t.ammo,e.ammo,p,d),g=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),g.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(l.x||0,l.y||0,l.z||0),g.setLinearUpperLimit(this.tmpBtVector3),r?(this.tmpBtVector3.setValue(0,0,0),g.setAngularLowerLimit(this.tmpBtVector3),g.setAngularUpperLimit(this.tmpBtVector3)):(console.log(m,h),g.setAngularLowerLimit(this.toAmmoV3(m,-Math.PI)),g.setAngularUpperLimit(this.toAmmoV3(h,Math.PI)));for(let t=0;t<3;t++)g.enableSpring(t,u),g.setStiffness(t,o),g.setDamping(t,n);return this.physicsWorld.addConstraint(g,i),g}coneTwist(t,e,s,i=!0){const{frameA:o,frameB:n}=s,r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue(o?.x||0,o?.y||0,o?.z||0);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue(n?.x||0,n?.y||0,n?.z||0);this.getTransform(t.ammo,e.ammo);const l=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,r,a);return l.setAngularOnly(!0),this.physicsWorld.addConstraint(l,i),l}dof(t,e,s={},i=!0){const{offset:o,center:n=!1}=s,r={x:0,y:0,z:0,...o},a=this.getTransform(t.ammo,e.ammo,r,n),l=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,a.transformA,a.transformB,!0),{linearLowerLimit:m,linearUpperLimit:h,angularLowerLimit:c,angularUpperLimit:d}=s,u=this.toAmmoV3(m),p=this.toAmmoV3(h),y=this.toAmmoV3(c,-Math.PI),g=this.toAmmoV3(d,Math.PI);return l.setLinearLowerLimit(u),l.setLinearUpperLimit(p),l.setAngularLowerLimit(y),l.setAngularUpperLimit(g),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),Ammo.destroy(g),this.physicsWorld.addConstraint(l,i),l}}class w{fn;context;once;constructor(t,e,s=!1){this.fn=t,this.context=e,this.once=s}}const x=(t,e,s,i,o)=>{if("function"!=typeof s)throw new TypeError("The listener must be a function");const n=new w(s,i||t,o);return t._events.has(e)?t._events.get(e).fn?t._events.set(e,[t._events.get(e),n]):t._events.get(e).push(n):(t._events.set(e,n),t._eventsCount++),t},v=(t,e)=>{0==--t._eventsCount?t._events=new Map:t._events.delete(e)};class V{static get VERSION(){return"0.0.7"}_events=new Map;_eventsCount=0;eventNames(){return Array.from(this._events.keys())}listeners(t){const e=this._events.get(t);if(!e)return[];if(e.fn)return[e.fn];for(var s=0,i=e.length,o=new Array(i);s<i;s++)o[s]=e[s].fn;return o}listenerCount(t){const e=this._events.get(t);return e?e.fn?1:e.length:0}emit(t,...e){if(!this._events.has(t))return!1;const s=this._events.get(t);let i;if(s.fn)return s.once&&this.removeListener(t,s.fn,void 0,!0),s.fn.call(s.context,...e),!0;{const o=s.length;for(i=0;i<o;i++)s[i].once&&this.removeListener(t,s[i].fn,void 0,!0),s[i].fn.call(s[i].context,...e)}return!0}on(t,e,s){return x(this,t,e,s,!1)}once(t,e,s){return x(this,t,e,s,!0)}removeListener(t,e,s,i){if(!this._events.has(t))return this;if(!e)return v(this,t),this;const o=this._events.get(t);if(o.fn)o.fn!==e||i&&!o.once||s&&o.context!==s||v(this,t);else{for(var n=0,r=[],a=o.length;n<a;n++)(o[n].fn!==e||i&&!o[n].once||s&&o[n].context!==s)&&r.push(o[n]);r.length?this._events.set(t,1===r.length?r[0]:r):v(this,t)}return this}removeAllListeners(t){return t?this._events.delete(t)&&v(this,t):(this._events=new Map,this._eventsCount=0),this}get off(){return this.removeListener}get addListener(){return this.on}}const A="hull",C="hacd",_="vhacd",M="mesh",T="all",B="manual",P=function(){const t=new d.Vector3,e=new d.Vector3,s=new d.Matrix4;return function(i,o,n,r={}){if(r.type=A,z(r),r.fit===B)return console.warn("cannot use fit: manual with type: hull"),null;const a=L(i,o),l=new Ammo.btVector3,m=new Ammo.btConvexHullShape;m.setMargin(r.margin),e.addVectors(a.max,a.min).multiplyScalar(.5);let h=0;for(let t=0;t<i.length;t++)h+=i[t].length/3;const c=r.hullMaxVertices||1e5;h>c&&console.warn(`too many vertices for hull shape; sampling ~${c} from ~${h} vertices`);const d=Math.min(1,c/h);for(let n=0;n<i.length;n++){const r=i[n];s.fromArray(o[n]);for(let o=0;o<r.length;o+=3){const a=n===i.length-1&&o===r.length-3;(Math.random()<=d||a)&&(t.set(r[o],r[o+1],r[o+2]).applyMatrix4(s).sub(e),l.setValue(t.x,t.y,t.z),m.addPoint(l,a))}}let u=m;if(m.getNumVertices()>=100){const t=new Ammo.btShapeHull(m);t.buildHull(r.margin),Ammo.destroy(m),u=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(l),D(u,r,R(n,r)),u}}(),S=function(){const t=new d.Vector3,e=new d.Vector3,s=new d.Matrix4;return function(i,o,n,r,a={}){if(a.type=C,z(a),a.fit===B)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=L(i,o),m=R(r,a);let h=0,c=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<i.length;t++)h+=i[t].length/3,n&&n[t]?c+=n[t].length/3:c+=i[t].length/9;const d=new Ammo.HACD;a.hasOwnProperty("compacityWeight")&&d.SetCompacityWeight(a.compacityWeight),a.hasOwnProperty("volumeWeight")&&d.SetVolumeWeight(a.volumeWeight),a.hasOwnProperty("nClusters")&&d.SetNClusters(a.nClusters),a.hasOwnProperty("nVerticesPerCH")&&d.SetNVerticesPerCH(a.nVerticesPerCH),a.hasOwnProperty("concavity")&&d.SetConcavity(a.concavity);const u=Ammo._malloc(3*h*8),p=Ammo._malloc(3*c*4);d.SetPoints(u),d.SetTriangles(p),d.SetNPoints(h),d.SetNTriangles(c);let y=u/8,g=p/4;for(let r=0;r<i.length;r++){const a=i[r];s.fromArray(o[r]);for(let i=0;i<a.length;i+=3)t.set(a[i+0],a[i+1],a[i+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[y+0]=t.x,Ammo.HEAPF64[y+1]=t.y,Ammo.HEAPF64[y+2]=t.z,y+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[g]=t[e],g++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[g]=t,g++}d.Compute(),Ammo._free(u),Ammo._free(p);const f=d.GetNClusters(),b=[];for(let t=0;t<f;t++){const e=new Ammo.btConvexHullShape;e.setMargin(a.margin);const s=d.GetNPointsCH(t),i=d.GetNTrianglesCH(t),o=Ammo._malloc(3*s*8),n=Ammo._malloc(3*i*4);d.GetCH(t,o,n);const r=o/8;for(let t=0;t<s;t++){const i=new Ammo.btVector3,o=Ammo.HEAPF64[r+3*t+0],n=Ammo.HEAPF64[r+3*t+1],a=Ammo.HEAPF64[r+3*t+2];i.setValue(o,n,a),e.addPoint(i,t===s-1),Ammo.destroy(i)}D(e,a,m),b.push(e)}return b}}(),E=function(){const t=new d.Vector3,e=new d.Vector3,s=new d.Matrix4;return function(i,o,n,r,a={}){if(a.type=_,z(a),a.fit===B)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=L(i,o),m=R(r,a);let h=0,c=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<i.length;t++)h+=i[t].length/3,n&&n[t]?c+=n[t].length/3:c+=i[t].length/9;const d=new Ammo.VHACD,u=new Ammo.Parameters;a.hasOwnProperty("resolution")&&u.set_m_resolution(a.resolution),a.hasOwnProperty("depth")&&u.set_m_depth(a.depth),a.hasOwnProperty("concavity")&&u.set_m_concavity(a.concavity),a.hasOwnProperty("planeDownsampling")&&u.set_m_planeDownsampling(a.planeDownsampling),a.hasOwnProperty("convexhullDownsampling")&&u.set_m_convexhullDownsampling(a.convexhullDownsampling),a.hasOwnProperty("alpha")&&u.set_m_alpha(a.alpha),a.hasOwnProperty("beta")&&u.set_m_beta(a.beta),a.hasOwnProperty("gamma")&&u.set_m_gamma(a.gamma),a.hasOwnProperty("pca")&&u.set_m_pca(a.pca),a.hasOwnProperty("mode")&&u.set_m_mode(a.mode),a.hasOwnProperty("maxNumVerticesPerCH")&&u.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH),a.hasOwnProperty("minVolumePerCH")&&u.set_m_minVolumePerCH(a.minVolumePerCH),a.hasOwnProperty("convexhullApproximation")&&u.set_m_convexhullApproximation(a.convexhullApproximation),a.hasOwnProperty("oclAcceleration")&&u.set_m_oclAcceleration(a.oclAcceleration);const p=Ammo._malloc(3*h*8+3),y=Ammo._malloc(3*c*4);let g=p/8,f=y/4;for(let r=0;r<i.length;r++){const a=i[r];s.fromArray(o[r]);for(let i=0;i<a.length;i+=3)t.set(a[i+0],a[i+1],a[i+2]).applyMatrix4(s).sub(e),Ammo.HEAPF64[g+0]=t.x,Ammo.HEAPF64[g+1]=t.y,Ammo.HEAPF64[g+2]=t.z,g+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[f]=t[e],f++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[f]=t,f++}d.Compute(p,3,h,y,3,c,u),Ammo._free(p),Ammo._free(y);const b=d.GetNConvexHulls(),w=[],x=new Ammo.ConvexHull;for(let t=0;t<b;t++){d.GetConvexHull(t,x);const e=x.get_m_nPoints(),s=(x.get_m_points(),new Ammo.btConvexHullShape);s.setMargin(a.margin);for(let t=0;t<e;t++){const i=new Ammo.btVector3,o=x.get_m_points(3*t+0),n=x.get_m_points(3*t+1),r=x.get_m_points(3*t+2);i.setValue(o,n,r),s.addPoint(i,t===e-1),Ammo.destroy(i)}D(s,a,m),w.push(s)}return Ammo.destroy(x),Ammo.destroy(d),w}}(),k=function(){const t=new d.Vector3,e=new d.Vector3,s=new d.Vector3,i=new d.Matrix4;return function(o,n,r,a,l={}){if(l.type=M,z(l),l.fit===B)return console.warn("cannot use fit: manual with type: mesh"),null;const m=R(a,l),h=new Ammo.btVector3,c=new Ammo.btVector3,d=new Ammo.btVector3,u=new Ammo.btTriangleMesh(!0,!1);for(let a=0;a<o.length;a++){const l=o[a],m=r[a]?r[a]:null;if(i.fromArray(n[a]),m)for(let o=0;o<m.length;o+=3){const n=3*m[o],r=3*m[o+1],a=3*m[o+2];t.set(l[n],l[n+1],l[n+2]).applyMatrix4(i),e.set(l[r],l[r+1],l[r+2]).applyMatrix4(i),s.set(l[a],l[a+1],l[a+2]).applyMatrix4(i),h.setValue(t.x,t.y,t.z),c.setValue(e.x,e.y,e.z),d.setValue(s.x,s.y,s.z),u.addTriangle(h,c,d,!1)}else for(let o=0;o<l.length;o+=9)t.set(l[o+0],l[o+1],l[o+2]).applyMatrix4(i),e.set(l[o+3],l[o+4],l[o+5]).applyMatrix4(i),s.set(l[o+6],l[o+7],l[o+8]).applyMatrix4(i),h.setValue(t.x,t.y,t.z),c.setValue(e.x,e.y,e.z),d.setValue(s.x,s.y,s.z),u.addTriangle(h,c,d,!1)}const p=new Ammo.btVector3(m.x,m.y,m.z);let y;return u.setScaling(p),Ammo.destroy(p),y=l.concave?new Ammo.btBvhTriangleMeshShape(u,!0,!0):new Ammo.btConvexTriangleMeshShape(u,!0),y.resources=[u],Ammo.destroy(h),Ammo.destroy(c),Ammo.destroy(d),D(y,l),y}}();function z(t){t.type=t.type||A,t.margin=t.hasOwnProperty("margin")?t.margin:.01}const D=function(t,e,s){},O=function(){const t=new d.Matrix4;return function(e,s,i){parseInt(d.REVISION)>=123?t.copy(e.matrixWorld).invert():t.getInverse(e.matrixWorld);(new d.Vector3).setFromMatrixScale(e.matrixWorld),e.traverse((o=>{const n=new d.Matrix4;if(o.isMesh&&(s.includeInvisible||o.el&&o.el.object3D.visible||o.visible)){let s;if(o===e?n.identity():(o.updateWorldMatrix(!0),n.multiplyMatrices(t,o.matrixWorld)),o.geometry.isBufferGeometry){const t=o.geometry.attributes.position;if(t.isInterleavedBufferAttribute){s=new Float32Array(t.count*t.itemSize);let e=t.offset,i=0;for(;i<s.length;){for(let o=0;o<t.itemSize;o++)s[i++]=t.array[e+o];e+=t.data.stride}}else s=t.array}i(o.geometry.isBufferGeometry?s:o.geometry.vertices,n.elements,o.geometry.index?o.geometry.index.array:null)}}))}}(),R=function(){const t=new d.Matrix4;return function(e,s={}){const i=new d.Vector3(1,1,1);return s.fit===T&&(t.fromArray(e),i.setFromMatrixScale(t)),i}}(),L=(function(){const t=new d.Vector3}(),function(t,e){const s=new d.Box3;let i=1/0,o=1/0,n=1/0,r=-1/0,a=-1/0,l=-1/0;return s.min.set(0,0,0),s.max.set(0,0,0),F(t,e,(t=>{t.x<i&&(i=t.x),t.y<o&&(o=t.y),t.z<n&&(n=t.z),t.x>r&&(r=t.x),t.y>a&&(a=t.y),t.z>l&&(l=t.z)})),s.min.set(i,o,n),s.max.set(r,a,l),s}),F=function(){const t=new d.Vector3,e=new d.Matrix4;return function(s,i,o){for(let n=0;n<s.length;n++){e.fromArray(i[n]);for(let i=0;i<s[n].length;i+=3)t.set(s[n][i],s[n][i+1],s[n][i+2]).applyMatrix4(e),o(t)}}}();const W=class{_defaultMaterial;constructor(){this._defaultMaterial=new d.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}};class j{scene;defaultMaterial;isHeadless;constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new W}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),capsule:(t={},e={})=>this.makeCapsule(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),capsule:(t={},e={})=>this.addCapsule(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,s){const{x:i=0,y:o=0,z:n=0}=s;let r;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":r=new d.Line(t,e);break;case"PointsMaterial":r=new d.Points(t,e);break;default:r=new y(t,e)}return r.position.set(i,o,n),r.castShadow=r.receiveShadow=!0,r}makeExtrude(t,e){const{x:s,y:i,z:o,name:n,shape:r,autoCenter:a=!0,breakable:l=!1,...m}=t,{depth:h=1,bevelEnabled:c=!1}=m,u=new d.ExtrudeGeometry(r,{depth:h,bevelEnabled:c,...m}),p=this.addMaterial(e),y=this.createMesh(u,p,{x:s,y:i,z:o});return a&&y.geometry.center(),y.name=n||`body_id_${y.id}`,y.shape="extrude",y}addExtrude(t,e={}){const s=this.makeExtrude(t,e);return this.addExisting(s),s}makePlane(t,e){const{x:s,y:i,z:o,name:n,breakable:r=!1,...a}=t,l=new d.PlaneGeometry(a.width||1,a.height||1,a.widthSegments||1,a.heightSegments||1),m=this.addMaterial(e);m.side=d.DoubleSide;const h=this.createMesh(l,m,{x:s,y:i,z:o});return h.name=n||`body_id_${h.id}`,h.shape="plane",h}addPlane(t,e){const s=this.makePlane(t,e);return this.addExisting(s),s}makeSphere(t,e){const{x:s,y:i,z:o,name:n,breakable:r=!1,...a}=t,l=new d.SphereGeometry(a.radius||1,a.widthSegments||16,a.heightSegments||12,a.phiStart||void 0,a.phiLength||void 0,a.thetaStart||void 0,a.thetaLength||void 0),m=this.addMaterial(e),h=this.createMesh(l,m,{x:s,y:i,z:o});return h.name=n||`body_id_${h.id}`,h.shape="sphere",h}addSphere(t={},e={}){const s=this.makeSphere(t,e);return this.addExisting(s),s}makeBox(t,e){const{x:s,y:i,z:o,name:n,breakable:r=!1,...a}=t,l=new d.BoxGeometry(a.width||1,a.height||1,a.depth||1,a.widthSegments||void 0,a.heightSegments||void 0,a.depthSegments||void 0),m=this.addMaterial(e),h=this.createMesh(l,m,{x:s,y:i,z:o});return h.name=n||`body_id_${h.id}`,h.shape="box",h}addBox(t={},e={}){const s=this.makeBox(t,e);return this.addExisting(s),s}addGround(t,e={}){const s=this.makeBox(t,e);return s.rotateX(d.MathUtils.degToRad(90)),this.addExisting(s),s}makeCapsule(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:r=!1,...a}=t,l=new d.CapsuleGeometry(a.radius||.5,a.length||1,a.capSegments||4,a.radialSegments||16),m=this.addMaterial(e),h=this.createMesh(l,m,{x:s,y:i,z:o});return h.name=n||`body_id_${h.id}`,h.shape="capsule",h}addCapsule(t={},e={}){const s=this.makeCapsule(t,e);return this.addExisting(s),s}makeCylinder(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:r=!1,...a}=t,l=new d.CylinderGeometry(a.radiusTop||1,a.radiusBottom||1,a.height||1,a.radiusSegments||void 0,a.heightSegments||void 0,a.openEnded||void 0,a.thetaStart||void 0,a.thetaLength||void 0),m=this.addMaterial(e),h=this.createMesh(l,m,{x:s,y:i,z:o});return h.name=n||`body_id_${h.id}`,h.shape="cylinder",h}addCylinder(t={},e={}){const s=this.makeCylinder(t,e);return this.addExisting(s),s}makeCone(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:r=!1,...a}=t,l=new d.ConeGeometry(a.radius||1,a.height||1,a.radiusSegments||8,a.heightSegments||1,a.openEnded||!1,a.thetaStart||0,a.thetaLength||2*Math.PI),m=this.addMaterial(e),h=this.createMesh(l,m,{x:s,y:i,z:o});return h.name=n||`body_id_${h.id}`,h.shape="cone",h}addCone(t={},e={}){const s=this.makeCone(t,e);return this.addExisting(s),s}makeTorus(t={},e={}){const{x:s,y:i,z:o,name:n,breakable:r=!1,...a}=t,l=new d.TorusGeometry(a.radius||void 0,a.tube||void 0,a.radialSegments||void 0,a.tubularSegments||void 0,a.arc||void 0),m=this.addMaterial(e),h=this.createMesh(l,m,{x:s,y:i,z:o});return h.name=n||`body_id_${h.id}`,h.shape="torus",h}addTorus(t={},e={}){const s=this.makeTorus(t,e);return this.addExisting(s),s}addMaterial(t={}){const e=Object.keys(t)[0];let s;if("headless"===this.scene)return this.defaultMaterial.get();switch(e){case"basic":s=new d.MeshBasicMaterial(t.basic);break;case"normal":s=new d.MeshNormalMaterial(t.normal);break;case"standard":s=new d.MeshStandardMaterial(t.standard);break;case"lambert":s=new d.MeshLambertMaterial(t.lambert);break;case"phong":s=new d.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?s=new d.MeshPhysicalMaterial(t.physical):(a("You need to pass parameters to the physical material. (Fallback to default material)"),s=this.defaultMaterial.get());break;case"toon":s=new d.MeshToonMaterial(t.toon);break;case"line":s=new d.LineBasicMaterial(t.line);break;case"points":s=new d.PointsMaterial(t.points);break;case"custom":s=t.custom||this.defaultMaterial.get();break;default:s=this.defaultMaterial.get()}return s}}class H extends V{worldTransform;physicsWorld;addCollider(t,e,s){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",(i=>{const{bodies:o,event:n}=i;o[0]?.name&&o[1]?.name&&t?.name&&e?.name&&(o[0].name===t.name&&o[1].name===e.name||o[1].name===t.name&&o[0].name===e.name)&&s(n)})))}}const I=1,N=32768;const U=class{scene;world;options;debugDrawMode;geometry;index;mesh;enabled;debugDrawer;warnedOnce;constructor(t,e,s={}){this.scene=t,this.world=e,this.options=s,this.debugDrawMode=s.debugDrawMode||I;const i=this.debugDrawMode&N||!1,o=s.maxBufferSize||1e6;this.geometry=new d.BufferGeometry;const n=new Float32Array(3*o),r=new Float32Array(3*o);this.geometry.setAttribute("position",new d.BufferAttribute(n,3).setUsage(d.StaticDrawUsage)),this.geometry.setAttribute("color",new d.BufferAttribute(r,3).setUsage(d.StaticDrawUsage)),this.index=0;const a=new d.LineBasicMaterial({vertexColors:!0,depthTest:!i});this.mesh=new d.LineSegments(this.geometry,a),i&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,s){const i=Ammo.HEAPF32,o=i[(s+0)/4],n=i[(s+4)/4],r=i[(s+8)/4],a=i[(t+0)/4],l=i[(t+4)/4],m=i[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,l,m),this.geometry.attributes.color.setXYZ(this.index++,o,n,r);const h=i[(e+0)/4],c=i[(e+4)/4],d=i[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,h,c,d),this.geometry.attributes.color.setXYZ(this.index++,o,n,r)}drawContactPoint(t,e,s,i,o){const n=Ammo.HEAPF32,r=n[(o+0)/4],a=n[(o+4)/4],l=n[(o+8)/4],m=n[(t+0)/4],h=n[(t+4)/4],c=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,m,h,c),this.geometry.attributes.color.setXYZ(this.index++,r,a,l);const d=n[(e+0)/4]*s,u=n[(e+4)/4]*s,p=n[(e+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,m+d,h+u,c+p),this.geometry.attributes.color.setXYZ(this.index++,r,a,l)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}},G=new d.Vector3,Q=new d.Line3,$=new d.Plane,q=new d.Vector3,X=new d.Triangle;class Z{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new tt,this.unassigned=new tt,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.vertices.push(new J(t[e]));this.compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse((function(t){const s=t.geometry;if(void 0!==s){const i=s.attributes.position;if(void 0!==i)for(let s=0,o=i.count;s<o;s++){const o=new d.Vector3;o.fromBufferAttribute(i,s).applyMatrix4(t.matrixWorld),e.push(o)}}})),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let s=0,i=e.length;s<i;s++){if(e[s].distanceToPoint(t)>this.tolerance)return!1}return!0}intersectRay(t,e){const s=this.faces;let i=-1/0,o=1/0;for(let e=0,n=s.length;e<n;e++){const n=s[e],r=n.distanceToPoint(t.origin),a=n.normal.dot(t.direction);if(r>0&&a>=0)return null;const l=0!==a?-r/a:0;if(!(l<=0)&&(a>0?o=Math.min(l,o):i=Math.max(l,i),i>o))return null}return i!==-1/0?t.at(i,e):t.at(o,e),e}intersectsRay(t){return null!==this.intersectRay(t,G)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(t,e){return t.face=e,null===e.outside?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}removeVertexFromFace(t,e){return t===e.outside&&(null!==t.next&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}removeAllVerticesFromFace(t){if(null!==t.outside){const e=t.outside;let s=t.outside;for(;null!==s.next&&s.next.face===t;)s=s.next;return this.assigned.removeSubList(e,s),e.prev=s.next=null,t.outside=null,e}}deleteFaceVertices(t,e){const s=this.removeAllVerticesFromFace(t);if(void 0!==s)if(void 0===e)this.unassigned.appendChain(s);else{let t=s;do{const s=t.next;e.distanceToPoint(t.point)>this.tolerance?this.addVertexToFace(t,e):this.unassigned.append(t),t=s}while(null!==t)}return this}resolveUnassignedPoints(t){if(!1===this.unassigned.isEmpty()){let e=this.unassigned.first();do{const s=e.next;let i=this.tolerance,o=null;for(let s=0;s<t.length;s++){const n=t[s];if(0===n.mark){const t=n.distanceToPoint(e.point);if(t>i&&(i=t,o=n),i>1e3*this.tolerance)break}}null!==o&&this.addVertexToFace(e,o),e=s}while(null!==e)}return this}computeExtremes(){const t=new d.Vector3,e=new d.Vector3,s=[],i=[];for(let t=0;t<3;t++)s[t]=i[t]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let o=0,n=this.vertices.length;o<n;o++){const n=this.vertices[o],r=n.point;for(let e=0;e<3;e++)r.getComponent(e)<t.getComponent(e)&&(t.setComponent(e,r.getComponent(e)),s[e]=n);for(let t=0;t<3;t++)r.getComponent(t)>e.getComponent(t)&&(e.setComponent(t,r.getComponent(t)),i[t]=n)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:i}}computeInitialHull(){const t=this.vertices,e=this.computeExtremes(),s=e.min,i=e.max;let o=0,n=0;for(let t=0;t<3;t++){const e=i[t].point.getComponent(t)-s[t].point.getComponent(t);e>o&&(o=e,n=t)}const r=s[n],a=i[n];let l,m;o=0,Q.set(r.point,a.point);for(let e=0,s=this.vertices.length;e<s;e++){const s=t[e];if(s!==r&&s!==a){Q.closestPointToPoint(s.point,!0,q);const t=q.distanceToSquared(s.point);t>o&&(o=t,l=s)}}o=-1,$.setFromCoplanarPoints(r.point,a.point,l.point);for(let e=0,s=this.vertices.length;e<s;e++){const s=t[e];if(s!==r&&s!==a&&s!==l){const t=Math.abs($.distanceToPoint(s.point));t>o&&(o=t,m=s)}}const h=[];if($.distanceToPoint(m.point)<0){h.push(Y.create(r,a,l),Y.create(m,a,r),Y.create(m,l,a),Y.create(m,r,l));for(let t=0;t<3;t++){const e=(t+1)%3;h[t+1].getEdge(2).setTwin(h[0].getEdge(e)),h[t+1].getEdge(1).setTwin(h[e+1].getEdge(0))}}else{h.push(Y.create(r,l,a),Y.create(m,r,a),Y.create(m,a,l),Y.create(m,l,r));for(let t=0;t<3;t++){const e=(t+1)%3;h[t+1].getEdge(2).setTwin(h[0].getEdge((3-t)%3)),h[t+1].getEdge(0).setTwin(h[e+1].getEdge(1))}}for(let t=0;t<4;t++)this.faces.push(h[t]);for(let e=0,s=t.length;e<s;e++){const s=t[e];if(s!==r&&s!==a&&s!==l&&s!==m){o=this.tolerance;let t=null;for(let e=0;e<4;e++){const i=this.faces[e].distanceToPoint(s.point);i>o&&(o=i,t=this.faces[e])}null!==t&&this.addVertexToFace(s,t)}}return this}reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];0===s.mark&&t.push(s)}return this.faces=t,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let t,e=0;const s=this.assigned.first().face;let i=s.outside;do{const o=s.distanceToPoint(i.point);o>e&&(e=o,t=i),i=i.next}while(null!==i&&i.face===s);return t}}computeHorizon(t,e,s,i){let o;this.deleteFaceVertices(s),s.mark=1,o=null===e?e=s.getEdge(0):e.next;do{const e=o.twin,s=e.face;0===s.mark&&(s.distanceToPoint(t)>this.tolerance?this.computeHorizon(t,e,s,i):i.push(o)),o=o.next}while(o!==e);return this}addAdjoiningFace(t,e){const s=Y.create(t,e.tail(),e.head());return this.faces.push(s),s.getEdge(-1).setTwin(e.twin),s.getEdge(0)}addNewFaces(t,e){this.newFaces=[];let s=null,i=null;for(let o=0;o<e.length;o++){const n=e[o],r=this.addAdjoiningFace(t,n);null===s?s=r:r.next.setTwin(i),this.newFaces.push(r.face),i=r}return s.next.setTwin(i),this}addVertexToHull(t){const e=[];return this.unassigned.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,e),this.addNewFaces(t,e),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let t;for(this.computeInitialHull();void 0!==(t=this.nextVertexToAdd());)this.addVertexToHull(t);return this.reindexFaces(),this.cleanup(),this}}class Y{constructor(){this.normal=new d.Vector3,this.midpoint=new d.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(t,e,s){const i=new Y,o=new K(t,i),n=new K(e,i),r=new K(s,i);return o.next=r.prev=n,n.next=o.prev=r,r.next=n.prev=o,i.edge=o,i.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),s=this.edge.next.head();return X.set(t.point,e.point,s.point),X.getNormal(this.normal),X.getMidpoint(this.midpoint),this.area=X.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class K{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return null!==e?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class J{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class tt{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,null===e.prev?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,null===e.next?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(null===this.head?this.head=t:this.tail.next=t,t.prev=this.tail;null!==t.next;)t=t.next;return this.tail=t,this}remove(t){return null===t.prev?this.head=t.next:t.prev.next=t.next,null===t.next?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return null===t.prev?this.head=e.next:t.prev.next=e.next,null===e.next?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return null===this.head}}class et extends d.BufferGeometry{constructor(t=[]){super();const e=[],s=[],i=(new Z).setFromPoints(t).faces;for(let t=0;t<i.length;t++){const o=i[t];let n=o.edge;do{const t=n.head().point;e.push(t.x,t.y,t.z),s.push(o.normal.x,o.normal.y,o.normal.z),n=n.next}while(n!==o.edge)}this.setAttribute("position",new d.Float32BufferAttribute(e,3)),this.setAttribute("normal",new d.Float32BufferAttribute(s,3))}}const st=t=>new(window.THREE&&window.THREE.ConvexGeometry?window.THREE.ConvexGeometry:et)(t),it=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new d.Line3,this.tempPlane1=new d.Plane,this.tempPlane2=new d.Plane,this.tempPlane_Cut=new d.Plane,this.tempCM1=new d.Vector3,this.tempCM2=new d.Vector3,this.tempVector3=new d.Vector3,this.tempVector3_2=new d.Vector3,this.tempVector3_3=new d.Vector3,this.tempVector3_P0=new d.Vector3,this.tempVector3_P1=new d.Vector3,this.tempVector3_P2=new d.Vector3,this.tempVector3_N0=new d.Vector3,this.tempVector3_N1=new d.Vector3,this.tempVector3_AB=new d.Vector3,this.tempVector3_CB=new d.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var s=0;s<900;s++)this.segments[s]=!1};var ot;it.prototype={constructor:it,prepareBreakableObject:function(t,e,s,i,o){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var n=t.userData.ammoPhysicsData;n.mass=e,n.velocity=s.clone(),n.angularVelocity=i.clone(),n.breakable=o},subdivideByImpact:function(t,e,s,i,o){var n=[],r=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,s),r.setFromCoplanarPoints(e,t.position,this.tempVector3);var l=o+i,m=this;return function o(h,c,d,u){if(Math.random()<.05*u||u>l)n.push(h);else{var p=Math.PI;0===u?(a.normal.copy(r.normal),a.constant=r.constant):u<=i?(p=(d-c)*(.2+.6*Math.random())+c,m.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,p).add(e),a.setFromCoplanarPoints(e,m.tempVector3,m.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,m.tempVector3_2.copy(e).sub(h.position).applyAxisAngle(s,p).add(h.position),m.tempVector3_3.copy(s).add(h.position),a.setFromCoplanarPoints(h.position,m.tempVector3_3,m.tempVector3_2)),m.cutByPlane(h,a,m.tempResultObjects);var y=m.tempResultObjects.object1,g=m.tempResultObjects.object2;y&&o(y,c,p,u+1),g&&o(g,p,d,u+1)}}(t,0,2*Math.PI,0),n},cutByPlane:function(t,e,s){var i=t.geometry,o=i.attributes.position.array,n=i.attributes.normal.array,r=o.length/3,l=r/3,m=i.getIndex();function h(t,e){var s=3*t+e;return m?m[s]:s}m&&(l=(m=m.array).length/3);for(var c=[],u=[],p=this.smallDelta,y=r*r,g=0;g<y;g++)this.segments[g]=!1;var f=this.tempVector3_P0,b=this.tempVector3_P1,w=this.tempVector3_N0,x=this.tempVector3_N1;for(g=0;g<l-1;g++){var v=h(g,0),V=h(g,1),A=h(g,2);w.set(n[v],n[v]+1,n[v]+2);for(var C=g+1;C<l;C++){var _=h(C,0),M=h(C,1),T=h(C,2);x.set(n[_],n[_]+1,n[_]+2),1-w.dot(x)<p&&(v===_||v===M||v===T?V===_||V===M||V===T?(this.segments[v*r+V]=!0,this.segments[V*r+v]=!0):(this.segments[A*r+v]=!0,this.segments[v*r+A]=!0):V!==_&&V!==M&&V!==T||(this.segments[A*r+V]=!0,this.segments[V*r+A]=!0))}}var B=this.tempPlane_Cut;t.updateMatrix(),it.transformPlaneToLocalSpace(e,t.matrix,B);for(g=0;g<l;g++)for(var P=h(g,0),S=h(g,1),E=h(g,2),k=0;k<3;k++){var z=0===k?P:1===k?S:E,D=0===k?S:1===k?E:P;if(!this.segments[z*r+D]){this.segments[z*r+D]=!0,this.segments[D*r+z]=!0,f.set(o[3*z],o[3*z+1],o[3*z+2]),b.set(o[3*D],o[3*D+1],o[3*D+2]);var O=0;(R=B.distanceToPoint(f))>p?(O=2,u.push(f.clone())):R<-p?(O=1,c.push(f.clone())):(O=3,c.push(f.clone()),u.push(f.clone()));var R,L=0;if((R=B.distanceToPoint(b))>p?(L=2,u.push(b.clone())):R<-p?(L=1,c.push(b.clone())):(L=3,c.push(b.clone()),u.push(b.clone())),1===O&&2===L||2===O&&1===L){this.tempLine1.start.copy(f),this.tempLine1.end.copy(b);var F=new d.Vector3;if(void 0===(F=B.intersectLine(this.tempLine1,F)))return console.error("Internal error: segment does not intersect plane."),s.segmentedObject1=null,s.segmentedObject2=null,0;c.push(F),u.push(F.clone())}}}var W=.5*t.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var j=0,H=c.length;if(H>0){for(g=0;g<H;g++)this.tempCM1.add(c[g]);this.tempCM1.divideScalar(H);for(g=0;g<H;g++){(U=c[g]).sub(this.tempCM1),j=Math.max(j,U.x,U.y,U.z)}this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);var I=0,N=u.length;if(N>0){for(g=0;g<N;g++)this.tempCM2.add(u[g]);this.tempCM2.divideScalar(N);for(g=0;g<N;g++){var U;(U=u[g]).sub(this.tempCM2),I=Math.max(I,U.x,U.y,U.z)}this.tempCM2.add(t.position)}var G=null,Q=null,$=0;if(H>4)try{(G=new d.Mesh(st(c),t.material)).position.copy(this.tempCM1),G.quaternion.copy(t.quaternion),G.userData=t.userData,this.prepareBreakableObject(G,W,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*j>this.minSizeForBreak),$++}catch(t){a("Error in ConvexObjectBreaker.ts",!0),a(t,!0)}if(N>4)try{(Q=new d.Mesh(st(u),t.material)).position.copy(this.tempCM2),Q.quaternion.copy(t.quaternion),Q.userData=t.userData,this.prepareBreakableObject(Q,W,t.userData.ammoPhysicsData.velocity,t.userData.ammoPhysicsData.angularVelocity,2*I>this.minSizeForBreak),$++}catch(t){a("Error in ConvexObjectBreaker.ts",!0),a(t,!0)}return s.object1=G,s.object2=Q,$}},it.transformFreeVector=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[4]*i+n[8]*o,t.y=n[1]*s+n[5]*i+n[9]*o,t.z=n[2]*s+n[6]*i+n[10]*o,t},it.transformFreeVectorInverse=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[1]*i+n[2]*o,t.y=n[4]*s+n[5]*i+n[6]*o,t.z=n[8]*s+n[9]*i+n[10]*o,t},it.transformTiedVectorInverse=function(t,e){var s=t.x,i=t.y,o=t.z,n=e.elements;return t.x=n[0]*s+n[1]*i+n[2]*o-n[12],t.y=n[4]*s+n[5]*i+n[6]*o-n[13],t.z=n[8]*s+n[9]*i+n[10]*o-n[14],t},it.transformPlaneToLocalSpace=(ot=new d.Vector3,function(t,e,s){s.normal.copy(t.normal),s.constant=t.constant;var i=it.transformTiedVectorInverse(t.coplanarPoint(ot),e);it.transformFreeVectorInverse(s.normal,e),s.constant=-i.dot(s.normal)});const nt=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){t instanceof Error&&console.error(t.message)}return!1})(),rt=(t,e)=>{var s=document.createElement("script");s.onload=()=>{e()},s.onerror=()=>{throw new Error(`failed to load ${t}`)},s.async=!0,s.src=t,document.head.appendChild(s)},at=(t,e)=>{rt(nt?`${t}/ammo.wasm.js`:`${t}/ammo.js`,(()=>e()))},lt=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),at(t,(()=>{Ammo().then((()=>{e()}))}))};const mt=function(t,e){e.forEach((e=>{Object.getOwnPropertyNames(e.prototype).forEach((s=>{Object.defineProperty(t.prototype,s,Object.getOwnPropertyDescriptor(e.prototype,s)||Object.create(null))}))}))};class ht{physics;type;_btRayFrom;_btRayTo;_btRayCallback;constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,s=0){this._btRayFrom.setValue(t,e,s)}setRayToWorld(t=0,e=0,s=0){this._btRayTo.setValue(t,e,s)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class ct{physics;type="closest";_btRayFrom=new Ammo.btVector3(0,0,0);_btRayTo=new Ammo.btVector3(0,0,0);_btRayCallback;constructor(t){this.physics=t}}class dt{physics;type="allHits";_btRayFrom=new Ammo.btVector3(0,0,0);_btRayTo=new Ammo.btVector3(0,0,0);_btRayCallback;constructor(t){this.physics=t}}mt(ct,[ht,class{physics;_btRayCallback;constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){return Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody).threeObject}}]),mt(dt,[ht,class{physics;_btRayCallback;constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const i=t.at(s);e.push({x:i.x(),y:i.y(),z:i.z()})}return e}getHitPointWorld(){return a("Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let s=t.size()-1;s>=0;s--){const i=t.at(s);e.push({x:i.x(),y:i.y(),z:i.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let s=e.size()-1;s>=0;s--){const i=Ammo.castObject(e.at(s),Ammo.btRigidBody);t.push(i.threeObject)}return t}}]);class ut{autoStart;startTime;oldTime;elapsedTime;running;constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}class pt extends V{scene;config;worldTransform;factory;isHeadless;rigidBodies=[];earlierDetectedCollisions=[];gravity;tmpEuler;tmpQuaternion;tmpVector3;tmpVector3a;tmpMatrix4;tmpMatrix4a;tmpBtVector3;tmpBtQuaternion;physicsWorld;debugDrawer;convexBreaker;addRigidBody;objectsToRemove;numObjectsToRemove;emptyV3;impactPoint;impactNormal;defaultMaterial;shapes;constraints;collisionEvents;complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"];constructor(t,e={}){super(),this.scene=t,this.config=e,this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new d.Euler,this.tmpQuaternion=new d.Quaternion,this.tmpVector3=new d.Vector3,this.tmpVector3a=new d.Vector3,this.tmpMatrix4=new d.Matrix4,this.tmpMatrix4a=new d.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new d.Vector3,this.impactPoint=new d.Vector3,this.impactNormal=new d.Vector3,"headless"!==t&&(this.defaultMaterial=new W),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){const e=Object.keys(t).includes("body")?t.body:t;if(void 0===e?.ammo)return;let s=e.ammo.threeObject;const i=s.name;if(i&&s&&s?.body?.ammo){s.body.isSoftBody?this.physicsWorld.removeSoftBody(s.body.ammo):this.physicsWorld.removeRigidBody(s.body.ammo),s.body.destructor(),s.body=void 0,s.hasBody=!1,delete e.ammo.threeObject;for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===i&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&s&&(s=null)}setup(){if(this.worldTransform=new Ammo.btTransform,"function"==typeof this.config.setupPhysicsWorld?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new it,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new H,this.factory=new j(this.scene),this.shapes=new f(this.factory,((t,e)=>this.addExisting(t,e))),this.constraints=new b(this.worldTransform,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new U(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let s;if(!e){const t=new Ammo.btDefaultCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),i=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver;s=new Ammo.btDiscreteDynamicsWorld(e,i,o,t)}if(e){const t=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),i=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver,n=new Ammo.btDefaultSoftBodySolver;s=new Ammo.btSoftRigidDynamicsWorld(e,i,o,t,n)}return s.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),s}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=e.material,t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,t.name=`${e.name}__DEBRIS_${t.id}`,this.scene.add(t),this.addExisting(t,{autoCenter:!0}),t.body.fractureImpulse=e.body.fractureImpulse,t.body.breakable=!1,setTimeout((()=>{t.body.breakable=!0}),2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0;t<this.rigidBodies.length;t++){const e=this.rigidBodies[t];e.body.impact=[];const s=e.body.ammo.getMotionState();if(s)if(s.getWorldTransform(this.worldTransform),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),s.setWorldTransform(this.worldTransform),e.body.needUpdate=!1;else if(e.body.skipUpdate);else if(!e.body.ammo.isStaticObject()){const t=this.worldTransform.getOrigin(),s=this.worldTransform.getRotation(),i=e.body.offset;if(e.body.ignoreScale)this.tmpVector3a.set(e.scale.x,e.scale.y,e.scale.z);else{const t=e.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(t.x(),t.y(),t.z())}this.tmpVector3.set(t.x()+i.x,t.y()+i.y,t.z()+i.z),this.tmpQuaternion.set(s.x(),s.y(),s.z(),s.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),e.parent?parseInt(d.REVISION)>=123?this.tmpMatrix4a.copy(e.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(e.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(e.position,e.quaternion,e.scale)}}}detectCollisions(){const t=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const e=this.physicsWorld.getDispatcher(),s=e.getNumManifolds();for(let i=0;i<s;i++){const s=e.getManifoldByIndexInternal(i),o=s.getNumContacts(),n=Ammo.castObject(s.getBody0(),Ammo.btRigidBody),r=Ammo.castObject(s.getBody1(),Ammo.btRigidBody),a=n.threeObject,l=r.threeObject;if(!a||!l)continue;if(""===n.name&&""===r.name)continue;const m=a.body?.checkCollisions,h=l.body?.checkCollisions,c=a.body.breakable,d=l.body.breakable,u=a.body.fractureImpulse,p=l.body.fractureImpulse,y=m||h,g=c||d;if(void 0===a.fragmentDepth&&(a.fragmentDepth=0),void 0===l.fragmentDepth&&(l.fragmentDepth=0),!y&&!g)continue;let f=!1,b=0,w="start";for(let e=0;e<o;e++){const i=s.getContactPoint(e);if(i.getDistance()<=0){f=!0;const e=i.getAppliedImpulse(),s=i.get_m_positionWorldOnB(),o=i.get_m_normalWorldOnB();if(m||h){const i=[a.uuid,l.uuid].sort(),n=`${i[0]}__${i[1]}`;if(this.earlierDetectedCollisions.find((t=>t.combinedName===n))&&(w="collision"),!t.find((t=>t.combinedName===n))){t.push({combinedName:n,collision:!0});const i={x:s.x(),y:s.y(),z:s.z()},r={x:o.x(),y:o.y(),z:o.z()};a.body.impact.push({impulse:e,point:i,normal:r,name:l.name}),l.body.impact.push({impulse:e,point:i,normal:r,name:a.name}),this.collisionEvents.emit("collision",{bodies:[a,l],event:w})}}e>=b&&(b=e,(c||d)&&(this.impactPoint.set(s.x(),s.y(),s.z()),this.impactNormal.set(o.x(),o.y(),o.z())));break}}if(!f)continue;if(!g)continue;const x=2;if(this.emptyV3.set(0,0,0),a.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:c,physicsBody:n},l.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:d,physicsBody:r},c&&b>u&&a.fragmentDepth<x){const t=this.convexBreaker.subdivideByImpact(a,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=n.getLinearVelocity(),i=n.getAngularVelocity(),o=t[s];o.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),o.userData.ammoPhysicsData.angularVelocity.set(i.x(),i.y(),i.z()),this.createDebrisFromBreakableObject(o,a)}this.objectsToRemove[this.numObjectsToRemove++]=a}if(d&&b>p&&l.fragmentDepth<x){const t=this.convexBreaker.subdivideByImpact(l,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let s=0;s<e;s++){const e=r.getLinearVelocity(),i=r.getAngularVelocity(),o=t[s];o.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),o.userData.ammoPhysicsData.angularVelocity.set(i.x(),i.y(),i.z()),this.createDebrisFromBreakableObject(o,l)}this.objectsToRemove[this.numObjectsToRemove++]=l}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach((e=>{const{combinedName:s}=e;if(!t.find((t=>t.combinedName===s))){const t=s.split("__"),e=this.rigidBodies.find((e=>e.uuid===t[0])),i=this.rigidBodies.find((e=>e.uuid===t[1])),o="end";e&&i&&this.collisionEvents.emit("collision",{bodies:[e,i],event:o})}})),this.earlierDetectedCollisions=[...t]}setGravity(t=0,e=-9.8,s=0){this.tmpBtVector3.setValue(t,e,s),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then((()=>{this.setup()})):this.setup():a("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,s)=>this.collisionEvents.addCollider(t,e,s),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),capsule:(t={},e={})=>this.shapes.addCapsule(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new ct(this):new dt(this)}}prepareThreeObjectForCollisionShape(t,e={}){const{autoCenter:s=!1}=e,i={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let o="unknown";const n=t.isMesh?t.geometry?.type:"unknown";/box/i.test(n)?o="box":/cone/i.test(n)?o="cone":/cylinder/i.test(n)?o="cylinder":/extrude/i.test(n)?o="extrude":/plane/i.test(n)?o="plane":/sphere/i.test(n)?o="sphere":/torus/i.test(n)&&(o="torus");let r={...i,...t?.geometry?.parameters};if(e.shape?(r={...i,...e},o=e.shape):t.shape&&(o=t.shape),Object.keys(r).forEach((t=>{void 0===r[t]&&i[t]&&(r[t]=i[t])})),s)if(t.isMesh&&t.geometry)t.geometry.center();else if(t.isGroup){const e=new d.Box3,s=new d.Vector3;e.setFromObject(t).getCenter(s),t.traverse((t=>{t.isMesh&&t.geometry.translate(-s.x,-s.y,-s.z)}))}return"cylinder"===o&&(r.radius=e.radius||r.radiusTop),"extrude"===o&&(o="hacd"),"mesh"!==o&&"convex"!==o||(o="convexMesh"),"concave"===o&&(o="concaveMesh"),"unknown"===o&&(a(`Shape for ${t?.name} not recognized! Will fallback to box.`),o="box"),{shape:o,params:r,object:t}}createCollisionShape(t,e,s){const i=s?.quaternion?s?.quaternion:new d.Quaternion(0,0,0,1),{axis:o="y"}=e,n=new Ammo.btVector3,r=s?.geometry;s&&r?.isGeometry&&(s.geometry=(new d.BufferGeometry).fromGeometry(r));let a,l={};switch(-1!==this.complexShapes.indexOf(t)&&(l=(t=>{const e=(new d.Matrix4).elements,s=[],i=[],o=[];return O(t,{},((t,e,n)=>{s.push(t),i.push(e),o.push(n)})),{vertices:s,matrices:i,indexes:o,matrixWorld:e}})(s)),t){case"box":n.setValue(e.width/2,e.height/2,e.depth/2),a=new Ammo.btBoxShape(n);break;case"sphere":a=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(o){case"y":n.setValue(e.radius,e.height/2,e.radius),a=new Ammo.btCylinderShape(n);break;case"x":n.setValue(e.height/2,e.radius,e.radius),a=new Ammo.btCylinderShapeX(n);break;case"z":n.setValue(e.radius,e.radius,e.height/2),a=new Ammo.btCylinderShapeZ(n)}break;case"cone":switch(o){case"y":a=new Ammo.btConeShape(e.radius,e.height);break;case"x":a=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":a=new Ammo.btConeShapeZ(e.radius,e.height)}break;case"capsule":switch(o){case"y":a=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":a=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":a=new Ammo.btCapsuleShapeZ(e.radius,e.height)}break;case"torus":a=((t,e)=>{const{radius:s=1,tube:i=.4,tubularSegments:o=8}=t,n=Math.PI,r=o,a=Math.sqrt(2*i*i-2*i*i*Math.cos(2*n/r)),l=new Ammo.btVector3(i,n/r+.5*a,i),m=new Ammo.btCylinderShape(l);m.setMargin(.05);const h=new Ammo.btCompoundShape,c=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,s,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<r;t++){const e=2*t*n/r,s=d.rotate(c,e),i=new Ammo.btTransform;u.setRotation(c,e+Math.PI/2),i.setIdentity(),i.setOrigin(s),i.setRotation(u),h.addChildShape(i,m)}return h})(e,i);break;case"plane":case"convexMesh":a=k(l.vertices,l.matrices,l.indexes,l.matrixWorld,{...e,concave:!1});break;case"hull":a=P(l.vertices,l.matrices,l.matrixWorld,e);break;case"hacd":a=S(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"vhacd":a=E(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"concaveMesh":a=k(l.vertices,l.matrices,l.indexes,l.matrixWorld,{...e,concave:!0})}Ammo.destroy(n);const{x:m,y:h,z:c}=e;return(m||h||c)&&(a._compoundOffset={x:m||0,y:h||0,z:c||0}),Array.isArray(a)&&(a=this.mergeCollisionShapesToCompoundShape(a)),a}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach((t=>{const{_childOffset:s,_compoundOffset:i}=t;if(s){const{pos:i,quat:o,scale:n,margin:r}=s,a=this.applyPosQuatScaleMargin(t,i,o,n,r);e.addChildShape(a,t)}else if(i){const s=new Ammo.btTransform;s.setIdentity(),s.setOrigin(new Ammo.btVector3(i.x,i.y,i.z)),e.addChildShape(s,t)}else{const s=new Ammo.btTransform;s.setIdentity(),e.addChildShape(s,t)}})),e}addExisting(t,e={}){const{hasBody:s}=t;if(s)return void a(`Object "${t.name}" already has a physical body!`);const i=new d.Vector3,o=new d.Quaternion,n=new d.Vector3;t.getWorldPosition(i),t.getWorldQuaternion(o),t.getWorldScale(n);const r="1"===(e.collisionFlags||0).toString(2).slice(-1),l="1"===(e.collisionFlags||0).toString(2).slice(-2,-1),{shape:m="unknown",compound:h=[],mass:c=(r||l?0:1),collisionFlags:u=0,collisionGroup:p=1,collisionMask:y=-1,offset:g,breakable:f=!1,addChildren:b=!0,margin:w=.01,ignoreScale:x=!1,fractureImpulse:v=1}=e;if(x&&n.set(1,1,1),h.length>=1){const e=h.map((t=>this.createCollisionShape(t.shape,t))),s=this.mergeCollisionShapesToCompoundShape(e),r=this.applyPosQuatScaleMargin(s,i,o,n,w),a=this.collisionShapeToRigidBody(s,r,c,l);return this.addRigidBodyToWorld(t,a,u,p,y,g),t.body.breakable=f,t.body.fractureImpulse=v,void(t.body.ignoreScale=x)}const V=[];if("unknown"!==m||t.isMesh){const s=this.prepareThreeObjectForCollisionShape(t,e),i=this.createCollisionShape(s.shape,s.params,s.object);V.push(i)}if("unknown"===m&&b&&t.children.length>=1&&t.children.forEach((t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),s=this.createCollisionShape(e.shape,e.params,e.object);s._childOffset={pos:t.position.clone(),quat:t.quaternion.clone(),scale:t.scale.clone(),margin:w},V.push(s)}})),0===V.length){const s=this.prepareThreeObjectForCollisionShape(t,e),i=this.createCollisionShape(s.shape,s.params,s.object);V.push(i)}const A=1===V.length?V[0]:this.mergeCollisionShapesToCompoundShape(V),C=this.applyPosQuatScaleMargin(A,i,o,n,w),_=this.collisionShapeToRigidBody(A,C,c,l);this.addRigidBodyToWorld(t,_,u,p,y,g),t.body.breakable=f,t.body.fractureImpulse=v,t.body.ignoreScale=x}addRigidBodyToWorld(t,e,s,i,o,n){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(e,i,o);const r=Object.values(e)[0];t.name||(t.name=`object-${t.id}`),e.name=t.name,t.body=new u(this,e),t.hasBody=!0,t.ptr=r,e.threeObject=t,n&&(t.body.offset={x:0,y:0,z:0,...n}),t.body.setCollisionFlags(s)}applyPosQuatScaleMargin(t,e=new d.Vector3,s=new d.Quaternion,i=new d.Vector3,o=.01){t.setMargin(o);const n=new Ammo.btQuaternion(0,0,0,1);n.setValue(s.x,s.y,s.z,s.w);const r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue(e.x,e.y,e.z),r.setRotation(n),Ammo.destroy(n);const a=new Ammo.btVector3(i.x,i.y,i.z);return t.setLocalScaling(a),Ammo.destroy(a),r}collisionShapeToRigidBody(t,e,s,i){const o=new Ammo.btDefaultMotionState(e),n=new Ammo.btVector3(0,0,0);s>0&&t.calculateLocalInertia(s,n);const r=new Ammo.btRigidBodyConstructionInfo(s,o,t,n),a=new Ammo.btRigidBody(r);return(s>0||i)&&a.setActivationState(4),a}}return o})()));