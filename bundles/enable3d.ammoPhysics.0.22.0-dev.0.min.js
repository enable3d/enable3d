/*! For license information please see enable3d.ammoPhysics.0.22.0-dev.0.min.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(require("THREE")):"function"==typeof define&&define.amd?define(["THREE"],e):"object"==typeof exports?exports.ENABLE3D=e(require("THREE")):t.ENABLE3D=e(t.THREE)}(self,(function(t){return(()=>{"use strict";var e={161:t=>{var e=Object.prototype.hasOwnProperty,o="~";function s(){}function i(t,e,o){this.fn=t,this.context=e,this.once=o||!1}function n(t,e,s,n,r){if("function"!=typeof s)throw new TypeError("The listener must be a function");var a=new i(s,n||t,r),l=o?o+e:e;return t._events[l]?t._events[l].fn?t._events[l]=[t._events[l],a]:t._events[l].push(a):(t._events[l]=a,t._eventsCount++),t}function r(t,e){0==--t._eventsCount?t._events=new s:delete t._events[e]}function a(){this._events=new s,this._eventsCount=0}Object.create&&(s.prototype=Object.create(null),(new s).__proto__||(o=!1)),a.prototype.eventNames=function(){var t,s,i=[];if(0===this._eventsCount)return i;for(s in t=this._events)e.call(t,s)&&i.push(o?s.slice(1):s);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(t)):i},a.prototype.listeners=function(t){var e=o?o+t:t,s=this._events[e];if(!s)return[];if(s.fn)return[s.fn];for(var i=0,n=s.length,r=new Array(n);i<n;i++)r[i]=s[i].fn;return r},a.prototype.listenerCount=function(t){var e=o?o+t:t,s=this._events[e];return s?s.fn?1:s.length:0},a.prototype.emit=function(t,e,s,i,n,r){var a=o?o+t:t;if(!this._events[a])return!1;var l,m,c=this._events[a],h=arguments.length;if(c.fn){switch(c.once&&this.removeListener(t,c.fn,void 0,!0),h){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,s),!0;case 4:return c.fn.call(c.context,e,s,i),!0;case 5:return c.fn.call(c.context,e,s,i,n),!0;case 6:return c.fn.call(c.context,e,s,i,n,r),!0}for(m=1,l=new Array(h-1);m<h;m++)l[m-1]=arguments[m];c.fn.apply(c.context,l)}else{var d,u=c.length;for(m=0;m<u;m++)switch(c[m].once&&this.removeListener(t,c[m].fn,void 0,!0),h){case 1:c[m].fn.call(c[m].context);break;case 2:c[m].fn.call(c[m].context,e);break;case 3:c[m].fn.call(c[m].context,e,s);break;case 4:c[m].fn.call(c[m].context,e,s,i);break;default:if(!l)for(d=1,l=new Array(h-1);d<h;d++)l[d-1]=arguments[d];c[m].fn.apply(c[m].context,l)}}return!0},a.prototype.on=function(t,e,o){return n(this,t,e,o,!1)},a.prototype.once=function(t,e,o){return n(this,t,e,o,!0)},a.prototype.removeListener=function(t,e,s,i){var n=o?o+t:t;if(!this._events[n])return this;if(!e)return r(this,n),this;var a=this._events[n];if(a.fn)a.fn!==e||i&&!a.once||s&&a.context!==s||r(this,n);else{for(var l=0,m=[],c=a.length;l<c;l++)(a[l].fn!==e||i&&!a[l].once||s&&a[l].context!==s)&&m.push(a[l]);m.length?this._events[n]=1===m.length?m[0]:m:r(this,n)}return this},a.prototype.removeAllListeners=function(t){var e;return t?(e=o?o+t:t,this._events[e]&&r(this,e)):(this._events=new s,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=o,a.EventEmitter=a,t.exports=a},729:t=>{var e=Object.prototype.hasOwnProperty,o="~";function s(){}function i(t,e,o){this.fn=t,this.context=e,this.once=o||!1}function n(t,e,s,n,r){if("function"!=typeof s)throw new TypeError("The listener must be a function");var a=new i(s,n||t,r),l=o?o+e:e;return t._events[l]?t._events[l].fn?t._events[l]=[t._events[l],a]:t._events[l].push(a):(t._events[l]=a,t._eventsCount++),t}function r(t,e){0==--t._eventsCount?t._events=new s:delete t._events[e]}function a(){this._events=new s,this._eventsCount=0}Object.create&&(s.prototype=Object.create(null),(new s).__proto__||(o=!1)),a.prototype.eventNames=function(){var t,s,i=[];if(0===this._eventsCount)return i;for(s in t=this._events)e.call(t,s)&&i.push(o?s.slice(1):s);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(t)):i},a.prototype.listeners=function(t){var e=o?o+t:t,s=this._events[e];if(!s)return[];if(s.fn)return[s.fn];for(var i=0,n=s.length,r=new Array(n);i<n;i++)r[i]=s[i].fn;return r},a.prototype.listenerCount=function(t){var e=o?o+t:t,s=this._events[e];return s?s.fn?1:s.length:0},a.prototype.emit=function(t,e,s,i,n,r){var a=o?o+t:t;if(!this._events[a])return!1;var l,m,c=this._events[a],h=arguments.length;if(c.fn){switch(c.once&&this.removeListener(t,c.fn,void 0,!0),h){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,s),!0;case 4:return c.fn.call(c.context,e,s,i),!0;case 5:return c.fn.call(c.context,e,s,i,n),!0;case 6:return c.fn.call(c.context,e,s,i,n,r),!0}for(m=1,l=new Array(h-1);m<h;m++)l[m-1]=arguments[m];c.fn.apply(c.context,l)}else{var d,u=c.length;for(m=0;m<u;m++)switch(c[m].once&&this.removeListener(t,c[m].fn,void 0,!0),h){case 1:c[m].fn.call(c[m].context);break;case 2:c[m].fn.call(c[m].context,e);break;case 3:c[m].fn.call(c[m].context,e,s);break;case 4:c[m].fn.call(c[m].context,e,s,i);break;default:if(!l)for(d=1,l=new Array(h-1);d<h;d++)l[d-1]=arguments[d];c[m].fn.apply(c[m].context,l)}}return!0},a.prototype.on=function(t,e,o){return n(this,t,e,o,!1)},a.prototype.once=function(t,e,o){return n(this,t,e,o,!0)},a.prototype.removeListener=function(t,e,s,i){var n=o?o+t:t;if(!this._events[n])return this;if(!e)return r(this,n),this;var a=this._events[n];if(a.fn)a.fn!==e||i&&!a.once||s&&a.context!==s||r(this,n);else{for(var l=0,m=[],c=a.length;l<c;l++)(a[l].fn!==e||i&&!a[l].once||s&&a[l].context!==s)&&m.push(a[l]);m.length?this._events[n]=1===m.length?m[0]:m:r(this,n)}return this},a.prototype.removeAllListeners=function(t){var e;return t?(e=o?o+t:t,this._events[e]&&r(this,e)):(this._events=new s,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=o,a.EventEmitter=a,t.exports=a},227:(t,e)=>{e.Z=(t,e)=>{e.forEach((e=>{Object.getOwnPropertyNames(e.prototype).forEach((o=>{Object.defineProperty(t.prototype,o,Object.getOwnPropertyDescriptor(e.prototype,o))}))}))}},552:(t,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0});const s=o(428);e.default=class{constructor(){this._defaultMaterial=new s.MeshLambertMaterial({color:13421772})}get(){return this._defaultMaterial}}},804:(t,e,o)=>{e.k=void 0;const s=o(428);class i extends s.Group{constructor(){super(),this.isMesh=!1,this.hasBody=!1,this.name=`object-${this.id}`}}e.k=i},150:(t,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedMesh=void 0;const s=o(428);class i extends s.Mesh{constructor(t,e){super(t,e),this.vector3=new s.Vector3,this.isGroup=!1,this.hasBody=!1,this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}e.ExtendedMesh=i},71:(t,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.ExtendedObject3D=void 0;const s=o(428);class i extends s.Object3D{constructor(){super(),this.vector3=new s.Vector3,this.isGroup=!1,this.hasBody=!1,this.anims={},this._currentAnimation="",this._animationActions=new Map,this.name=`object-${this.id}`}setAction(t){console.warn("[enable3d] setAction(name) is deprecated. Use animation.play(name) instead!"),this.animationPlay(t)}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}get animation(){return{current:this._currentAnimation,add:(t,e)=>this.animationAdd(t,e),play:(t,e=500,o=!0)=>this.animationPlay(t,e,o),mixer:this.animationMixer}}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new s.AnimationMixer(this)),this._animationMixer}animationAdd(t,e){this._animationActions.set(t,this.animationMixer.clipAction(e))}animationPlay(t,e=500,o=!0){const i=this._animationActions.get(t),n=this._animationActions.get(this._currentAnimation);i&&(i.reset(),n&&(i.crossFadeFrom(n,e/1e3,!0),i.clampWhenFinished=!0),o||i.setLoop(s.LoopOnce,0),i.play()),this._currentAnimation=t}}e.ExtendedObject3D=i,e.default=i},896:function(t,e,o){var s=this&&this.__rest||function(t,e){var o={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(o[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(s=Object.getOwnPropertySymbols(t);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(t,s[i])&&(o[s[i]]=t[s[i]])}return o};Object.defineProperty(e,"__esModule",{value:!0});const i=o(428),n=o(150),r=o(0),a=o(552);e.default=class{constructor(t){this.scene=t,this.isHeadless="headless"===t,this.defaultMaterial=new a.default}get make(){return{plane:(t={},e={})=>this.makePlane(t,e),box:(t={},e={})=>this.makeBox(t,e),sphere:(t={},e={})=>this.makeSphere(t,e),cylinder:(t={},e={})=>this.makeCylinder(t,e),cone:(t={},e={})=>this.makeCone(t,e),torus:(t={},e={})=>this.makeTorus(t,e),extrude:(t,e={})=>this.makeExtrude(t,e)}}get add(){return{mesh:t=>this.addMesh(t),existing:t=>this.addExisting(t),plane:(t={},e={})=>this.addPlane(t,e),box:(t={},e={})=>this.addBox(t,e),ground:(t,e={})=>this.addGround(t,e),sphere:(t={},e={})=>this.addSphere(t,e),cylinder:(t={},e={})=>this.addCylinder(t,e),cone:(t={},e={})=>this.addCone(t,e),torus:(t={},e={})=>this.addTorus(t,e),extrude:(t,e={})=>this.addExtrude(t,e),material:(t={})=>this.addMaterial(t)}}addExisting(...t){"headless"!==this.scene&&this.scene.add(...t)}addMesh(t){if(Array.isArray(t))for(let e=0;e<t.length;e++)this.addExisting(t[e]);else this.addExisting(t);return this}createMesh(t,e,o){const{x:s=0,y:r=0,z:a=0}=o;let l;switch(!Array.isArray(e)&&e.type){case"LineBasicMaterial":l=new i.Line(t,e);break;case"PointsMaterial":l=new i.Points(t,e);break;default:l=new n.ExtendedMesh(t,e)}return l.position.set(s,r,a),l.castShadow=l.receiveShadow=!0,l}makeExtrude(t,e){const{x:o,y:n,z:r,name:a,shape:l,autoCenter:m=!0,breakable:c=!1}=t,h=s(t,["x","y","z","name","shape","autoCenter","breakable"]),{depth:d=1,bevelEnabled:u=!1}=h,p=new i.ExtrudeBufferGeometry(l,Object.assign({depth:d,bevelEnabled:u},h)),y=this.addMaterial(e),b=this.createMesh(p,y,{x:o,y:n,z:r});return m&&b.geometry.center(),b.name=a||`body_id_${b.id}`,b.shape="extrude",b}addExtrude(t,e={}){const o=this.makeExtrude(t,e);return this.addExisting(o),o}makePlane(t,e){const{x:o,y:n,z:r,name:a,breakable:l=!1}=t,m=s(t,["x","y","z","name","breakable"]),c=new i.PlaneBufferGeometry(m.width||1,m.height||1,m.widthSegments||1,m.heightSegments||1),h=this.addMaterial(e);h.side=i.DoubleSide;const d=this.createMesh(c,h,{x:o,y:n,z:r});return d.name=a||`body_id_${d.id}`,d.shape="plane",d}addPlane(t,e){const o=this.makePlane(t,e);return this.addExisting(o),o}makeSphere(t,e){const{x:o,y:n,z:r,name:a,breakable:l=!1}=t,m=s(t,["x","y","z","name","breakable"]),c=new i.SphereBufferGeometry(m.radius||1,m.widthSegments||16,m.heightSegments||12,m.phiStart||void 0,m.phiLength||void 0,m.thetaStart||void 0,m.thetaLength||void 0),h=this.addMaterial(e),d=this.createMesh(c,h,{x:o,y:n,z:r});return d.name=a||`body_id_${d.id}`,d.shape="sphere",d}addSphere(t={},e={}){const o=this.makeSphere(t,e);return this.addExisting(o),o}makeBox(t,e){const{x:o,y:n,z:r,name:a,breakable:l=!1}=t,m=s(t,["x","y","z","name","breakable"]),c=new i.BoxBufferGeometry(m.width||1,m.height||1,m.depth||1,m.widthSegments||void 0,m.heightSegments||void 0,m.depthSegments||void 0),h=this.addMaterial(e),d=this.createMesh(c,h,{x:o,y:n,z:r});return d.name=a||`body_id_${d.id}`,d.shape="box",d}addBox(t={},e={}){const o=this.makeBox(t,e);return this.addExisting(o),o}addGround(t,e={}){const o=this.makeBox(t,e);return o.rotateX(i.MathUtils.degToRad(90)),this.addExisting(o),o}makeCylinder(t={},e={}){const{x:o,y:n,z:r,name:a,breakable:l=!1}=t,m=s(t,["x","y","z","name","breakable"]),c=new i.CylinderBufferGeometry(m.radiusTop||1,m.radiusBottom||1,m.height||1,m.radiusSegments||void 0,m.heightSegments||void 0,m.openEnded||void 0,m.thetaStart||void 0,m.thetaLength||void 0),h=this.addMaterial(e),d=this.createMesh(c,h,{x:o,y:n,z:r});return d.name=a||`body_id_${d.id}`,d.shape="cylinder",d}addCylinder(t={},e={}){const o=this.makeCylinder(t,e);return this.addExisting(o),o}makeCone(t={},e={}){const{x:o,y:n,z:r,name:a,breakable:l=!1}=t,m=s(t,["x","y","z","name","breakable"]),c=new i.ConeBufferGeometry(m.radius||1,m.height||1,m.radiusSegments||8,m.heightSegments||1,m.openEnded||!1,m.thetaStart||0,m.thetaLength||2*Math.PI),h=this.addMaterial(e),d=this.createMesh(c,h,{x:o,y:n,z:r});return d.name=a||`body_id_${d.id}`,d.shape="cone",d}addCone(t={},e={}){const o=this.makeCone(t,e);return this.addExisting(o),o}makeTorus(t={},e={}){const{x:o,y:n,z:r,name:a,breakable:l=!1}=t,m=s(t,["x","y","z","name","breakable"]),c=new i.TorusBufferGeometry(m.radius||void 0,m.tube||void 0,m.radialSegments||void 0,m.tubularSegments||void 0,m.arc||void 0),h=this.addMaterial(e),d=this.createMesh(c,h,{x:o,y:n,z:r});return d.name=a||`body_id_${d.id}`,d.shape="torus",d}addTorus(t={},e={}){const o=this.makeTorus(t,e);return this.addExisting(o),o}addMaterial(t={}){const e=Object.keys(t)[0];let o;if("headless"===this.scene)return this.defaultMaterial.get();switch(e){case"basic":o=new i.MeshBasicMaterial(t.basic);break;case"normal":o=new i.MeshNormalMaterial(t.normal);break;case"standard":o=new i.MeshStandardMaterial(t.standard);break;case"lambert":o=new i.MeshLambertMaterial(t.lambert);break;case"phong":o=new i.MeshPhongMaterial(t.phong);break;case"physical":void 0!==t.physical?o=new i.MeshPhysicalMaterial(t.physical):(r.default("You need to pass parameters to the physical material. (Fallback to default material)"),o=this.defaultMaterial.get());break;case"toon":o=new i.MeshToonMaterial(t.toon);break;case"line":o=new i.LineBasicMaterial(t.line);break;case"points":o=new i.PointsMaterial(t.points);break;case"custom":o=t.custom||this.defaultMaterial.get();break;default:o=this.defaultMaterial.get()}return o}}},0:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.default=t=>{console.error(`%c [enable3d] ${t} `,"background: #222; color: #bada55")}},604:(t,e,o)=>{const s=o(161),i=o(428);e.Z=class{constructor(t,e){this.physics=t,this.ammo=e,this.ignoreScale=!1,this.isSoftBody=!1,this.offset={x:0,y:0,z:0},this.errors=[],this.checkCollisions=!1,this.breakable=!1,this.didUpdate=!1,this.skipUpdate=!1,this._emitUpdateEvents=!1,this._needUpdate=!1,this.tmpEuler=new i.Euler,this.tmpQuaternion=new i.Quaternion,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtVector3_1=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.eventEmitter=new s.EventEmitter,this.name=e.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){void 0===this.eventEmitter&&(this.eventEmitter=new s.EventEmitter)}get needUpdate(){return this._needUpdate}set needUpdate(t){!t&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=t}onUpdateEvent(t,e=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,e?this.eventEmitter.once("update",(()=>{t()})):this.eventEmitter.on("update",(()=>{t()}))}get on(){return{update:t=>this.onUpdateEvent(t),collision:t=>this.onCollision(t)}}get once(){return{update:t=>this.onUpdateEvent(t,!0)}}onCollision(t){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",(e=>{const{bodies:o,event:s}=e;o[0].name===this.name?t(o[1],s):o[1].name===this.name&&t(o[0],s)}))}transform(){const t=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(t)}refresh(){const t=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(t)}setRotation(t,e,o){const s=this.tmpEuler.set(t,e,o),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(s),this.tmpBtQuaternion.setValue(0,0,0,1);const n=this.tmpBtQuaternion;n.setValue(i.x,i.y,i.z,i.w),this.physics.worldTransform.setRotation(n)}get rotation(){let t,e,o;const s=this.physics.worldTransform.getRotation();let i=this.tmpQuaternion.set(s.x(),s.y(),s.z(),s.w());i.w>1&&(i=i.normalize());const n=2*Math.acos(i.w),r=Math.sqrt(1-i.w*i.w);return r<.001?(t=i.x,e=i.y,o=i.z):(t=i.x/r,e=i.y/r,o=i.z/r),{x:t*n,y:e*n,z:o*n}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(t,e,o){this.physics.worldTransform.getOrigin().setValue(t,e,o)}get position(){const t=this.physics.worldTransform;return{x:t.getOrigin().x(),y:t.getOrigin().y(),z:t.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(t){this.tmpBtVector3.setValue(t,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(t){this.tmpBtVector3.setValue(this.velocity.x,t,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(t){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,t),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(t){this.tmpBtVector3.setValue(t,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(t){this.tmpBtVector3.setValue(this.angularVelocity.x,t,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(t){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,t),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(t){this.tmpBtVector3.setValue(t,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(t){this.tmpBtVector3.setValue(0,t,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(t){this.tmpBtVector3.setValue(0,0,t),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(t,e){this.tmpBtVector3.setValue(t.x||0,t.y||0,t.z||0),this.tmpBtVector3_1.setValue(e.x||0,e.y||0,e.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(t){this.ammo.setCollisionFlags(t)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(t){this.ammo.setRestitution(t)}setBounciness(t){this.setRestitution(t)}setFriction(t){this.ammo.setFriction(t)}setDamping(t,e){this.ammo.setDamping(t,e)}setGravity(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(t,e,o){this.tmpBtVector3.setValue(t,e,o),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(t){this.ammo.setCcdMotionThreshold(t)}setCcdSweptSphereRadius(t){this.ammo.setCcdSweptSphereRadius(t)}}},173:(t,e,o)=>{e.G=void 0;const s=o(519);e.G=(t,e)=>{"undefined"!=typeof window&&(window.__loadPhysics=!0),s.default(t,(()=>{Ammo().then((()=>{e()}))}))}},979:(t,e,o)=>{Object.defineProperty(e,"__esModule",{value:!0}),e.Group=e.Points=e.Line=e.Material=e.Mesh=e.Object3D=e.AnimationAction=e.AnimationClip=e.AnimationMixer=e.ExtendedMesh=e.ExtendedObject3D=void 0;const s=o(71);Object.defineProperty(e,"ExtendedObject3D",{enumerable:!0,get:function(){return s.ExtendedObject3D}});const i=o(150);Object.defineProperty(e,"ExtendedMesh",{enumerable:!0,get:function(){return i.ExtendedMesh}});var n=o(428);Object.defineProperty(e,"AnimationMixer",{enumerable:!0,get:function(){return n.AnimationMixer}}),Object.defineProperty(e,"AnimationClip",{enumerable:!0,get:function(){return n.AnimationClip}}),Object.defineProperty(e,"AnimationAction",{enumerable:!0,get:function(){return n.AnimationAction}}),Object.defineProperty(e,"Object3D",{enumerable:!0,get:function(){return n.Object3D}}),Object.defineProperty(e,"Mesh",{enumerable:!0,get:function(){return n.Mesh}}),Object.defineProperty(e,"Material",{enumerable:!0,get:function(){return n.Material}}),Object.defineProperty(e,"Line",{enumerable:!0,get:function(){return n.Line}}),Object.defineProperty(e,"Points",{enumerable:!0,get:function(){return n.Points}}),Object.defineProperty(e,"Group",{enumerable:!0,get:function(){return n.Group}})},519:(t,e)=>{Object.defineProperty(e,"__esModule",{value:!0});const o=(()=>{try{if("object"==typeof WebAssembly&&"function"==typeof WebAssembly.instantiate){const t=new WebAssembly.Module(Uint8Array.of(0,97,115,109,1,0,0,0));if(t instanceof WebAssembly.Module)return new WebAssembly.Instance(t)instanceof WebAssembly.Instance}}catch(t){}return!1})();e.default=(t,e)=>{((t,e)=>{var o=document.createElement("script");o.onload=()=>{e()},o.onerror=()=>{throw new Error("failed to load "+t)},o.async=!0,o.src=t,document.head.appendChild(o)})(o?`${t}/ammo.wasm.js`:`${t}/ammo.js`,(()=>e()))}},428:e=>{e.exports=t}},o={};function s(t){if(o[t])return o[t].exports;var i=o[t]={exports:{}};return e[t].call(i.exports,i,i.exports,s),i.exports}s.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return s.d(e,{a:e}),e},s.d=(t,e)=>{for(var o in e)s.o(e,o)&&!s.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),s.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var i={};return(()=>{s.r(i),s.d(i,{AllHitsRaycaster:()=>E,AmmoPhysics:()=>D,Clock:()=>k,ClosestRaycaster:()=>j,ExtendedGroup:()=>r.k,ExtendedMesh:()=>n.ExtendedMesh,ExtendedObject3D:()=>o.ExtendedObject3D,PhysicsLoader:()=>P.G,Types:()=>O});var t=s(0),e=s(604),o=s(71),n=s(150),r=s(804);class a{constructor(t,e){this.worldTransform=t,this.physicsWorld=e,this.tmpBtVector3=new Ammo.btVector3}toAmmoV3(t,e=0){return new Ammo.btVector3(void 0!==(null==t?void 0:t.x)?t.x:e,void 0!==(null==t?void 0:t.y)?t.y:e,void 0!==(null==t?void 0:t.z)?t.z:e)}get addConstraints(){return{lock:(t,e,o)=>this.lock(t,e,o),fixed:(t,e,o)=>this.fixed(t,e,o),pointToPoint:(t,e,o,s)=>this.pointToPoint(t,e,o,s),hinge:(t,e,o,s)=>this.hinge(t,e,o,s),slider:(t,e,o={},s)=>this.slider(t,e,o,s),spring:(t,e,o={},s)=>this.spring(t,e,o,s),coneTwist:(t,e,o={frameA:{},frameB:{}},s)=>this.coneTwist(t,e,o,s),dof:(t,e,o,s)=>this.dof(t,e,o,s)}}getTransform(t,e,o={x:0,y:0,z:0},s=!1){o=Object.assign({x:0,y:0,z:0},o);const i=new Ammo.btTransform;if(i.setIdentity(),s){const s=(n=t.getWorldTransform().getOrigin(),r=e.getWorldTransform().getOrigin(),a=(n.x()-r.x())/2+o.x,l=(n.y()-r.y())/2+o.y,m=(n.z()-r.z())/2+o.z,new Ammo.btVector3(a,l,m)),i=new Ammo.btTransform;i.setIdentity(),i.setOrigin(s);const c=t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform());return c.op_mul(i),{transformA:c,transformB:i}}return i.setOrigin(new Ammo.btVector3(o.x,o.y,o.z)),{transformA:t.getCenterOfMassTransform().inverse().op_mul(e.getWorldTransform()).op_mul(i),transformB:i};var n,r,a,l,m}lock(t,e,o=!0){const s={x:0,y:0,z:0};return this.dof(t,e,{angularLowerLimit:s,angularUpperLimit:s},o)}fixed(t,e,o=!0){const s=this.getTransform(t.ammo,e.ammo);s.transformA.setRotation(t.ammo.getWorldTransform().getRotation()),s.transformB.setRotation(e.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(t.ammo,e.ammo,s.transformA,s.transformB);return this.physicsWorld.addConstraint(i,o),i}pointToPoint(t,e,o={},s=!0){const{pivotA:i,pivotB:n}=o,r=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),a=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),l=new Ammo.btPoint2PointConstraint(t.ammo,e.ammo,r,a);return this.physicsWorld.addConstraint(l,s),l}hinge(t,e,o={},s=!0){const{pivotA:i,pivotB:n,axisA:r,axisB:a}=o,l=new Ammo.btVector3((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0),m=new Ammo.btVector3((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),c=new Ammo.btVector3((null==r?void 0:r.x)||0,(null==r?void 0:r.y)||0,(null==r?void 0:r.z)||0),h=new Ammo.btVector3((null==a?void 0:a.x)||0,(null==a?void 0:a.y)||0,(null==a?void 0:a.z)||0),d=new Ammo.btHingeConstraint(t.ammo,e.ammo,l,m,c,h,!0);return this.physicsWorld.addConstraint(d,s),d}slider(t,e,o={},s=!0){const i=this.getTransform(t.ammo,e.ammo),{frameA:n={},frameB:r={},linearLowerLimit:a=0,linearUpperLimit:l=0,angularLowerLimit:m=0,angularUpperLimit:c=0}=o,h=i.transformA.getRotation();h.setEulerZYX(n.x||0,n.y||0,n.z||0),i.transformA.setRotation(h);const d=i.transformB.getRotation();d.setEulerZYX(r.x||0,r.y||0,r.z||0),i.transformB.setRotation(d);const u=new Ammo.btSliderConstraint(t.ammo,e.ammo,i.transformA,i.transformB,!0);return u.setLowerLinLimit(a),u.setUpperLinLimit(l),u.setLowerAngLimit(m),u.setUpperAngLimit(c),this.physicsWorld.addConstraint(u,s),u}spring(t,e,o={},s=!0){const{stiffness:i=50,damping:n=.01,angularLock:r=!1,linearLowerLimit:a={},linearUpperLimit:l={},angularLowerLimit:m={},angularUpperLimit:c={},offset:h={},center:d=!1,enableSpring:u=!0}=o,p=Object.assign({x:0,y:0,z:0},h),y=this.getTransform(t.ammo,e.ammo,p,d),b=new Ammo.btGeneric6DofSpringConstraint(t.ammo,e.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(a.x||0,a.y||0,a.z||0),b.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(l.x||0,l.y||0,l.z||0),b.setLinearUpperLimit(this.tmpBtVector3),r?(this.tmpBtVector3.setValue(0,0,0),b.setAngularLowerLimit(this.tmpBtVector3),b.setAngularUpperLimit(this.tmpBtVector3)):(console.log(m,c),b.setAngularLowerLimit(this.toAmmoV3(m,-Math.PI)),b.setAngularUpperLimit(this.toAmmoV3(c,Math.PI)));for(let t=0;t<3;t++)b.enableSpring(t,u),b.setStiffness(t,i),b.setDamping(t,n);return this.physicsWorld.addConstraint(b,s),b}coneTwist(t,e,o,s=!0){const{frameA:i,frameB:n}=o,r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue((null==i?void 0:i.x)||0,(null==i?void 0:i.y)||0,(null==i?void 0:i.z)||0);const a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((null==n?void 0:n.x)||0,(null==n?void 0:n.y)||0,(null==n?void 0:n.z)||0),this.getTransform(t.ammo,e.ammo);const l=new Ammo.btConeTwistConstraint(e.ammo,t.ammo,r,a);return l.setAngularOnly(!0),this.physicsWorld.addConstraint(l,s),l}dof(t,e,o={},s=!0){const{offset:i,center:n=!1}=o,r=Object.assign({x:0,y:0,z:0},i),a=this.getTransform(t.ammo,e.ammo,r,n),l=new Ammo.btGeneric6DofConstraint(t.ammo,e.ammo,a.transformA,a.transformB,!0),{linearLowerLimit:m,linearUpperLimit:c,angularLowerLimit:h,angularUpperLimit:d}=o,u=this.toAmmoV3(m),p=this.toAmmoV3(c),y=this.toAmmoV3(h,-Math.PI),b=this.toAmmoV3(d,Math.PI);return l.setLinearLowerLimit(u),l.setLinearUpperLimit(p),l.setAngularLowerLimit(y),l.setAngularUpperLimit(b),Ammo.destroy(u),Ammo.destroy(p),Ammo.destroy(y),Ammo.destroy(b),this.physicsWorld.addConstraint(l,s),l}}var l=s(729),m=s(428);const c="hull",h="manual",d=function(){const t=new m.Vector3,e=new m.Vector3,o=new m.Matrix4;return function(s,i,n,r={}){if(r.type=c,b(r),r.fit===h)return console.warn("cannot use fit: manual with type: hull"),null;const a=v(s,i),l=new Ammo.btVector3,m=new Ammo.btConvexHullShape;m.setMargin(r.margin),e.addVectors(a.max,a.min).multiplyScalar(.5);let d=0;for(let t=0;t<s.length;t++)d+=s[t].length/3;const u=r.hullMaxVertices||1e5;d>u&&console.warn(`too many vertices for hull shape; sampling ~${u} from ~${d} vertices`);const p=Math.min(1,u/d);for(let n=0;n<s.length;n++){const r=s[n];o.fromArray(i[n]);for(let i=0;i<r.length;i+=3){const a=n===s.length-1&&i===r.length-3;(Math.random()<=p||a)&&(t.set(r[i],r[i+1],r[i+2]).applyMatrix4(o).sub(e),l.setValue(t.x,t.y,t.z),m.addPoint(l,a))}}let y=m;if(m.getNumVertices()>=100){const t=new Ammo.btShapeHull(m);t.buildHull(r.margin),Ammo.destroy(m),y=new Ammo.btConvexHullShape(Ammo.getPointer(t.getVertexPointer()),t.numVertices()),Ammo.destroy(t)}return Ammo.destroy(l),g(y,r,w(n,r)),y}}(),u=function(){const t=new m.Vector3,e=new m.Vector3,o=new m.Matrix4;return function(s,i,n,r,a={}){if(a.type="hacd",b(a),a.fit===h)return console.warn("cannot use fit: manual with type: hacd"),[];if(!Ammo.hasOwnProperty("HACD"))return console.warn("HACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=v(s,i),m=w(r,a);let c=0,d=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<s.length;t++)c+=s[t].length/3,n&&n[t]?d+=n[t].length/3:d+=s[t].length/9;const u=new Ammo.HACD;a.hasOwnProperty("compacityWeight")&&u.SetCompacityWeight(a.compacityWeight),a.hasOwnProperty("volumeWeight")&&u.SetVolumeWeight(a.volumeWeight),a.hasOwnProperty("nClusters")&&u.SetNClusters(a.nClusters),a.hasOwnProperty("nVerticesPerCH")&&u.SetNVerticesPerCH(a.nVerticesPerCH),a.hasOwnProperty("concavity")&&u.SetConcavity(a.concavity);const p=Ammo._malloc(3*c*8),y=Ammo._malloc(3*d*4);u.SetPoints(p),u.SetTriangles(y),u.SetNPoints(c),u.SetNTriangles(d);let f=p/8,x=y/4;for(let r=0;r<s.length;r++){const a=s[r];o.fromArray(i[r]);for(let s=0;s<a.length;s+=3)t.set(a[s+0],a[s+1],a[s+2]).applyMatrix4(o).sub(e),Ammo.HEAPF64[f+0]=t.x,Ammo.HEAPF64[f+1]=t.y,Ammo.HEAPF64[f+2]=t.z,f+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[x]=t[e],x++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[x]=t,x++}u.Compute(),Ammo._free(p),Ammo._free(y);const A=u.GetNClusters(),V=[];for(let t=0;t<A;t++){const e=new Ammo.btConvexHullShape;e.setMargin(a.margin);const o=u.GetNPointsCH(t),s=u.GetNTrianglesCH(t),i=Ammo._malloc(3*o*8),n=Ammo._malloc(3*s*4);u.GetCH(t,i,n);const r=i/8;for(let t=0;t<o;t++){const s=new Ammo.btVector3,i=Ammo.HEAPF64[r+3*t+0],n=Ammo.HEAPF64[r+3*t+1],a=Ammo.HEAPF64[r+3*t+2];s.setValue(i,n,a),e.addPoint(s,t===o-1),Ammo.destroy(s)}g(e,a,m),V.push(e)}return V}}(),p=function(){const t=new m.Vector3,e=new m.Vector3,o=new m.Matrix4;return function(s,i,n,r,a={}){if(a.type="vhacd",b(a),a.fit===h)return console.warn("cannot use fit: manual with type: vhacd"),[];if(!Ammo.hasOwnProperty("VHACD"))return console.warn("VHACD unavailable in included build of Ammo.js. Visit https://github.com/mozillareality/ammo.js for the latest version."),[];const l=v(s,i),m=w(r,a);let c=0,d=0;e.addVectors(l.max,l.min).multiplyScalar(.5);for(let t=0;t<s.length;t++)c+=s[t].length/3,n&&n[t]?d+=n[t].length/3:d+=s[t].length/9;const u=new Ammo.VHACD,p=new Ammo.Parameters;a.hasOwnProperty("resolution")&&p.set_m_resolution(a.resolution),a.hasOwnProperty("depth")&&p.set_m_depth(a.depth),a.hasOwnProperty("concavity")&&p.set_m_concavity(a.concavity),a.hasOwnProperty("planeDownsampling")&&p.set_m_planeDownsampling(a.planeDownsampling),a.hasOwnProperty("convexhullDownsampling")&&p.set_m_convexhullDownsampling(a.convexhullDownsampling),a.hasOwnProperty("alpha")&&p.set_m_alpha(a.alpha),a.hasOwnProperty("beta")&&p.set_m_beta(a.beta),a.hasOwnProperty("gamma")&&p.set_m_gamma(a.gamma),a.hasOwnProperty("pca")&&p.set_m_pca(a.pca),a.hasOwnProperty("mode")&&p.set_m_mode(a.mode),a.hasOwnProperty("maxNumVerticesPerCH")&&p.set_m_maxNumVerticesPerCH(a.maxNumVerticesPerCH),a.hasOwnProperty("minVolumePerCH")&&p.set_m_minVolumePerCH(a.minVolumePerCH),a.hasOwnProperty("convexhullApproximation")&&p.set_m_convexhullApproximation(a.convexhullApproximation),a.hasOwnProperty("oclAcceleration")&&p.set_m_oclAcceleration(a.oclAcceleration);const y=Ammo._malloc(3*c*8+3),f=Ammo._malloc(3*d*4);let x=y/8,A=f/4;for(let r=0;r<s.length;r++){const a=s[r];o.fromArray(i[r]);for(let s=0;s<a.length;s+=3)t.set(a[s+0],a[s+1],a[s+2]).applyMatrix4(o).sub(e),Ammo.HEAPF64[x+0]=t.x,Ammo.HEAPF64[x+1]=t.y,Ammo.HEAPF64[x+2]=t.z,x+=3;if(n[r]){const t=n[r];for(let e=0;e<t.length;e++)Ammo.HEAP32[A]=t[e],A++}else for(let t=0;t<a.length/3;t++)Ammo.HEAP32[A]=t,A++}u.Compute(y,3,c,f,3,d,p),Ammo._free(y),Ammo._free(f);const V=u.GetNConvexHulls(),_=[],C=new Ammo.ConvexHull;for(let t=0;t<V;t++){u.GetConvexHull(t,C);const e=C.get_m_nPoints(),o=(C.get_m_points(),new Ammo.btConvexHullShape);o.setMargin(a.margin);for(let t=0;t<e;t++){const s=new Ammo.btVector3,i=C.get_m_points(3*t+0),n=C.get_m_points(3*t+1),r=C.get_m_points(3*t+2);s.setValue(i,n,r),o.addPoint(s,t===e-1),Ammo.destroy(s)}g(o,a,m),_.push(o)}return Ammo.destroy(C),Ammo.destroy(u),_}}(),y=function(){const t=new m.Vector3,e=new m.Vector3,o=new m.Vector3,s=new m.Matrix4;return function(i,n,r,a,l={}){if(l.type="mesh",b(l),l.fit===h)return console.warn("cannot use fit: manual with type: mesh"),null;const m=w(a,l),c=new Ammo.btVector3,d=new Ammo.btVector3,u=new Ammo.btVector3,p=new Ammo.btTriangleMesh(!0,!1);for(let a=0;a<i.length;a++){const l=i[a],m=r[a]?r[a]:null;if(s.fromArray(n[a]),m)for(let i=0;i<m.length;i+=3){const n=3*m[i],r=3*m[i+1],a=3*m[i+2];t.set(l[n],l[n+1],l[n+2]).applyMatrix4(s),e.set(l[r],l[r+1],l[r+2]).applyMatrix4(s),o.set(l[a],l[a+1],l[a+2]).applyMatrix4(s),c.setValue(t.x,t.y,t.z),d.setValue(e.x,e.y,e.z),u.setValue(o.x,o.y,o.z),p.addTriangle(c,d,u,!1)}else for(let i=0;i<l.length;i+=9)t.set(l[i+0],l[i+1],l[i+2]).applyMatrix4(s),e.set(l[i+3],l[i+4],l[i+5]).applyMatrix4(s),o.set(l[i+6],l[i+7],l[i+8]).applyMatrix4(s),c.setValue(t.x,t.y,t.z),d.setValue(e.x,e.y,e.z),u.setValue(o.x,o.y,o.z),p.addTriangle(c,d,u,!1)}const y=new Ammo.btVector3(m.x,m.y,m.z);let f;return p.setScaling(y),Ammo.destroy(y),f=l.concave?new Ammo.btBvhTriangleMeshShape(p,!0,!0):new Ammo.btConvexTriangleMeshShape(p,!0),f.resources=[p],Ammo.destroy(c),Ammo.destroy(d),Ammo.destroy(u),g(f,l),f}}();function b(t){t.type=t.type||c,t.margin=t.hasOwnProperty("margin")?t.margin:.01}const g=function(t,e,o){},f=function(){const t=new m.Matrix4;return function(e,o,s){parseInt(m.REVISION)>=123?t.copy(e.matrixWorld).invert():t.getInverse(e.matrixWorld),(new m.Vector3).setFromMatrixScale(e.matrixWorld),e.traverse((i=>{const n=new m.Matrix4;i.isMesh&&(o.includeInvisible||i.el&&i.el.object3D.visible||i.visible)&&(i===e?n.identity():(i.updateWorldMatrix(!0),n.multiplyMatrices(t,i.matrixWorld)),s(i.geometry.isBufferGeometry?i.geometry.attributes.position.array:i.geometry.vertices,n.elements,i.geometry.index?i.geometry.index.array:null))}))}}(),w=function(){const t=new m.Matrix4;return function(e,o={}){const s=new m.Vector3(1,1,1);return"all"===o.fit&&(t.fromArray(e),s.setFromMatrixScale(t)),s}}(),v=(new m.Vector3,function(t,e){const o=new m.Box3;let s=1/0,i=1/0,n=1/0,r=-1/0,a=-1/0,l=-1/0;return o.min.set(0,0,0),o.max.set(0,0,0),x(t,e,(t=>{t.x<s&&(s=t.x),t.y<i&&(i=t.y),t.z<n&&(n=t.z),t.x>r&&(r=t.x),t.y>a&&(a=t.y),t.z>l&&(l=t.z)})),o.min.set(s,i,n),o.max.set(r,a,l),o}),x=function(){const t=new m.Vector3,e=new m.Matrix4;return function(o,s,i){for(let n=0;n<o.length;n++){e.fromArray(s[n]);for(let s=0;s<o[n].length;s+=3)t.set(o[n][s],o[n][s+1],o[n][s+2]).applyMatrix4(e),i(t)}}}();var A=s(896),V=s.n(A);class _ extends l.EventEmitter{addCollider(t,e,o){t.body&&e.body&&(t.body.checkCollisions=!0,e.body.checkCollisions=!0,this.on("collision",(s=>{var i,n;const{bodies:r,event:a}=s;(null===(i=r[0])||void 0===i?void 0:i.name)&&(null===(n=r[1])||void 0===n?void 0:n.name)&&(null==t?void 0:t.name)&&(null==e?void 0:e.name)&&(r[0].name===t.name&&r[1].name===e.name||r[1].name===t.name&&r[0].name===e.name)&&o(a)})))}}const C=function(t,e){this.minSizeForBreak=t||1.4,this.smallDelta=e||1e-4,this.tempLine1=new m.Line3,this.tempPlane1=new m.Plane,this.tempPlane2=new m.Plane,this.tempPlane_Cut=new m.Plane,this.tempCM1=new m.Vector3,this.tempCM2=new m.Vector3,this.tempVector3=new m.Vector3,this.tempVector3_2=new m.Vector3,this.tempVector3_3=new m.Vector3,this.tempVector3_P0=new m.Vector3,this.tempVector3_P1=new m.Vector3,this.tempVector3_P2=new m.Vector3,this.tempVector3_N0=new m.Vector3,this.tempVector3_N1=new m.Vector3,this.tempVector3_AB=new m.Vector3,this.tempVector3_CB=new m.Vector3,this.tempResultObjects={object1:null,object2:null},this.segments=[];for(var o=0;o<900;o++)this.segments[o]=!1};var M;C.prototype={constructor:C,prepareBreakableObject:function(t,e,o,s,i){t.geometry.isBufferGeometry||console.error("THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry."),t.userData.ammoPhysicsData={};var n=t.userData.ammoPhysicsData;n.mass=e,n.velocity=o.clone(),n.angularVelocity=s.clone(),n.breakable=i},subdivideByImpact:function(t,e,o,s,i){var n=[],r=this.tempPlane1,a=this.tempPlane2;this.tempVector3.addVectors(e,o),r.setFromCoplanarPoints(e,t.position,this.tempVector3);var l=i+s,m=this;return function i(c,h,d,u){if(Math.random()<.05*u||u>l)n.push(c);else{var p=Math.PI;0===u?(a.normal.copy(r.normal),a.constant=r.constant):u<=s?(p=(d-h)*(.2+.6*Math.random())+h,m.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(o,p).add(e),a.setFromCoplanarPoints(e,m.tempVector3,m.tempVector3_2)):(p=(.5*(1&u)+.2*(2-Math.random()))*Math.PI,m.tempVector3_2.copy(e).sub(c.position).applyAxisAngle(o,p).add(c.position),m.tempVector3_3.copy(o).add(c.position),a.setFromCoplanarPoints(c.position,m.tempVector3_3,m.tempVector3_2)),m.cutByPlane(c,a,m.tempResultObjects);var y=m.tempResultObjects.object1,b=m.tempResultObjects.object2;y&&i(y,h,p,u+1),b&&i(b,p,d,u+1)}}(t,0,2*Math.PI,0),n},cutByPlane:function(e,o,s){var i=e.geometry,n=i.attributes.position.array,r=i.attributes.normal.array,a=n.length/3,l=a/3,c=i.getIndex();function h(t,e){var o=3*t+e;return c?c[o]:o}c&&(l=(c=c.array).length/3);for(var d=[],u=[],p=this.smallDelta,y=a*a,b=0;b<y;b++)this.segments[b]=!1;var g=this.tempVector3_P0,f=this.tempVector3_P1,w=this.tempVector3_N0,v=this.tempVector3_N1;for(b=0;b<l-1;b++){var x=h(b,0),A=h(b,1),V=h(b,2);w.set(r[x],r[x]+1,r[x]+2);for(var _=b+1;_<l;_++){var M=h(_,0),P=h(_,1),B=h(_,2);v.set(r[M],r[M]+1,r[M]+2),1-w.dot(v)<p&&(x===M||x===P||x===B?A===M||A===P||A===B?(this.segments[x*a+A]=!0,this.segments[A*a+x]=!0):(this.segments[V*a+x]=!0,this.segments[x*a+V]=!0):A!==M&&A!==P&&A!==B||(this.segments[V*a+A]=!0,this.segments[A*a+V]=!0))}}var O=this.tempPlane_Cut;for(e.updateMatrix(),C.transformPlaneToLocalSpace(o,e.matrix,O),b=0;b<l;b++)for(var S=h(b,0),T=h(b,1),j=h(b,2),E=0;E<3;E++){var k=0===E?S:1===E?T:j,D=0===E?T:1===E?j:S;if(!this.segments[k*a+D]){this.segments[k*a+D]=!0,this.segments[D*a+k]=!0,g.set(n[3*k],n[3*k+1],n[3*k+2]),f.set(n[3*D],n[3*D+1],n[3*D+2]);var z=0;(L=O.distanceToPoint(g))>p?(z=2,u.push(g.clone())):L<-p?(z=1,d.push(g.clone())):(z=3,d.push(g.clone()),u.push(g.clone()));var L,R=0;if((L=O.distanceToPoint(f))>p?(R=2,u.push(f.clone())):L<-p?(R=1,d.push(f.clone())):(R=3,d.push(f.clone()),u.push(f.clone())),1===z&&2===R||2===z&&1===R){this.tempLine1.start.copy(g),this.tempLine1.end.copy(f);var W=new m.Vector3;if(void 0===(W=O.intersectLine(this.tempLine1,W)))return console.error("Internal error: segment does not intersect plane."),s.segmentedObject1=null,s.segmentedObject2=null,0;d.push(W),u.push(W.clone())}}}var F=.5*e.userData.ammoPhysicsData.mass;this.tempCM1.set(0,0,0);var H=0,I=d.length;if(I>0){for(b=0;b<I;b++)this.tempCM1.add(d[b]);for(this.tempCM1.divideScalar(I),b=0;b<I;b++)(N=d[b]).sub(this.tempCM1),H=Math.max(H,N.x,N.y,N.z);this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);var U=0,G=u.length;if(G>0){for(b=0;b<G;b++)this.tempCM2.add(u[b]);for(this.tempCM2.divideScalar(G),b=0;b<G;b++){var N;(N=u[b]).sub(this.tempCM2),U=Math.max(U,N.x,N.y,N.z)}this.tempCM2.add(e.position)}var Q=null,Z=null,q=0;if(I>4)try{(Q=new m.Mesh(new m.ConvexGeometry(d),e.material)).position.copy(this.tempCM1),Q.quaternion.copy(e.quaternion),Q.userData=e.userData,this.prepareBreakableObject(Q,F,e.userData.ammoPhysicsData.velocity,e.userData.ammoPhysicsData.angularVelocity,2*H>this.minSizeForBreak),q++}catch(e){(0,t.default)("Error in ConvexObjectBreaker.ts"),(0,t.default)(e)}if(G>4)try{(Z=new m.Mesh(new m.ConvexGeometry(u),e.material)).position.copy(this.tempCM2),Z.quaternion.copy(e.quaternion),Z.userData=e.userData,this.prepareBreakableObject(Z,F,e.userData.ammoPhysicsData.velocity,e.userData.ammoPhysicsData.angularVelocity,2*U>this.minSizeForBreak),q++}catch(e){(0,t.default)("Error in ConvexObjectBreaker.ts"),(0,t.default)(e)}return s.object1=Q,s.object2=Z,q}},C.transformFreeVector=function(t,e){var o=t.x,s=t.y,i=t.z,n=e.elements;return t.x=n[0]*o+n[4]*s+n[8]*i,t.y=n[1]*o+n[5]*s+n[9]*i,t.z=n[2]*o+n[6]*s+n[10]*i,t},C.transformFreeVectorInverse=function(t,e){var o=t.x,s=t.y,i=t.z,n=e.elements;return t.x=n[0]*o+n[1]*s+n[2]*i,t.y=n[4]*o+n[5]*s+n[6]*i,t.z=n[8]*o+n[9]*s+n[10]*i,t},C.transformTiedVectorInverse=function(t,e){var o=t.x,s=t.y,i=t.z,n=e.elements;return t.x=n[0]*o+n[1]*s+n[2]*i-n[12],t.y=n[4]*o+n[5]*s+n[6]*i-n[13],t.z=n[8]*o+n[9]*s+n[10]*i-n[14],t},C.transformPlaneToLocalSpace=(M=new m.Vector3,function(t,e,o){o.normal.copy(t.normal),o.constant=t.constant;var s=C.transformTiedVectorInverse(t.coplanarPoint(M),e);C.transformFreeVectorInverse(o.normal,e),o.constant=-s.dot(o.normal)});var P=s(173),B=s(552),O=s(979),S=s(227);class T{constructor(t){this.physics=t}setRayFromWorld(t=0,e=0,o=0){this._btRayFrom.setValue(t,e,o)}setRayToWorld(t=0,e=0,o=0){this._btRayTo.setValue(t,e,o)}hasHit(){return this._btRayCallback.hasHit()}rayTest(){void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback),this._btRayCallback="closest"===this.type?new Ammo.ClosestRayResultCallback(this._btRayFrom,this._btRayTo):new Ammo.AllHitsRayResultCallback(this._btRayFrom,this._btRayTo),this.physics.physicsWorld.rayTest(this._btRayFrom,this._btRayTo,this._btRayCallback)}destroy(){void 0!==this._btRayFrom&&Ammo.destroy(this._btRayFrom),void 0!==this._btRayTo&&Ammo.destroy(this._btRayTo),void 0!==this._btRayCallback&&Ammo.destroy(this._btRayCallback)}}class j{constructor(t){this.physics=t,this.type="closest",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}class E{constructor(t){this.physics=t,this.type="allHits",this._btRayFrom=new Ammo.btVector3(0,0,0),this._btRayTo=new Ammo.btVector3(0,0,0)}}(0,S.Z)(j,[T,class{constructor(t){this.physics=t}getHitPointWorld(){const t=this._btRayCallback.get_m_hitPointWorld();return{x:t.x(),y:t.y(),z:t.z()}}getHitNormalWorld(){const t=this._btRayCallback.get_m_hitNormalWorld();return{x:t.x(),y:t.y(),z:t.z()}}getCollisionObject(){return Ammo.castObject(this._btRayCallback.get_m_collisionObject(),Ammo.btRigidBody).threeObject}}]),(0,S.Z)(E,[T,class{constructor(t){this.physics=t}getHitPointsWorld(){const t=this._btRayCallback.get_m_hitPointWorld(),e=[];for(let o=t.size()-1;o>=0;o--){const s=t.at(o);e.push({x:s.x(),y:s.y(),z:s.z()})}return e}getHitPointWorld(){return console.warn("[enable3d] Use getHitPointsWorld() instead of getHitPointWorld() for the AllHitsRayCaster!"),this.getHitPointsWorld()}getHitNormalsWorld(){const t=this._btRayCallback.get_m_hitNormalWorld(),e=[];for(let o=t.size()-1;o>=0;o--){const s=t.at(o);e.push({x:s.x(),y:s.y(),z:s.z()})}return e}getCollisionObjects(){const t=[],e=this._btRayCallback.get_m_collisionObjects();for(let o=e.size()-1;o>=0;o--){const s=Ammo.castObject(e.at(o),Ammo.btRigidBody);t.push(s.threeObject)}return t}}]);class k{constructor(t=!0){this.autoStart=void 0===t||t,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let t=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){let e=("undefined"==typeof performance?Date:performance).now();t=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=t}return t}}class D extends l.EventEmitter{constructor(t,e={}){super(),this.scene=t,this.config=e,this.rigidBodies=[],this.earlierDetectedCollisions=[],this.complexShapes=["plane","hull","hacd","vhacd","convexMesh","concaveMesh"],this.gravity=e.gravity||{x:0,y:-9.81,z:0},this.isHeadless="headless"===t,this.tmpEuler=new m.Euler,this.tmpQuaternion=new m.Quaternion,this.tmpVector3=new m.Vector3,this.tmpVector3a=new m.Vector3,this.tmpMatrix4=new m.Matrix4,this.tmpMatrix4a=new m.Matrix4,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new m.Vector3,this.impactPoint=new m.Vector3,this.impactNormal=new m.Vector3,"headless"!==t&&(this.defaultMaterial=new B.default),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var e;const o=Object.keys(t).includes("body")?t.body:t;if(void 0===(null==o?void 0:o.ammo))return;const s=o.ammo.name;let i=o.ammo.threeObject;if(s&&i&&(null===(e=null==i?void 0:i.body)||void 0===e?void 0:e.ammo)){i.body.isSoftBody?this.physicsWorld.removeSoftBody(i.body.ammo):this.physicsWorld.removeRigidBody(i.body.ammo),i.body.destructor(),i.body=void 0,i.hasBody=!1,delete o.ammo.threeObject;for(let t=0;t<this.rigidBodies.length;t++)this.rigidBodies[t].name===s&&(this.rigidBodies.splice(t,1),t--)}"headless"===this.scene&&i&&(i=null)}setup(){if(this.worldTransform=new Ammo.btTransform,"function"==typeof this.config.setupPhysicsWorld?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),"headless"!==this.scene){this.convexBreaker=new C,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new _,this.factory=new(V())(this.scene),this.shapes=new class{constructor(t,e){this.factory=t,this.addExisting=e}addPlane(t={},e={}){const o=this.factory.add.plane(t,e);return this.addExisting(o,t),o}addSphere(t={},e={}){const o=this.factory.add.sphere(t,e);return this.addExisting(o,t),o}addBox(t={},e={}){const o=this.factory.add.box(t,e);return this.addExisting(o,t),o}addGround(t,e={}){const o=this.factory.add.ground(t,e),s=Object.assign(Object.assign({},t),{mass:0,collisionFlags:1});return this.addExisting(o,s),o}addCylinder(t={},e={}){const o=this.factory.add.cylinder(t,e);return this.addExisting(o,t),o}addCone(t={},e={}){const o=this.factory.add.cone(t,e);return this.addExisting(o,t),o}addTorus(t={},e={}){const o=this.factory.add.torus(t,e);return this.addExisting(o,t),o}addExtrude(t,e={}){const o=this.factory.add.extrude(t,e);return o.translateX(1),this.addExisting(o),o}}(this.factory,((t,e)=>this.addExisting(t,e))),this.constraints=new a(this.worldTransform,this.physicsWorld),"headless"!==this.scene&&(this.debugDrawer=new class{constructor(t,e,o={}){this.scene=t,this.world=e,this.options=o,this.debugDrawMode=o.debugDrawMode||1;const s=32768&this.debugDrawMode||!1,i=o.maxBufferSize||1e6;this.geometry=new m.BufferGeometry;const n=new Float32Array(3*i),r=new Float32Array(3*i);this.geometry.setAttribute("position",new m.BufferAttribute(n,3).setUsage(m.StaticDrawUsage)),this.geometry.setAttribute("color",new m.BufferAttribute(r,3).setUsage(m.StaticDrawUsage)),this.index=0;const a=new m.LineBasicMaterial({vertexColors:!0,depthTest:!s});this.mesh=new m.LineSegments(this.geometry,a),s&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(0!=this.index&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(t,e,o){const s=Ammo.HEAPF32,i=s[(o+0)/4],n=s[(o+4)/4],r=s[(o+8)/4],a=s[(t+0)/4],l=s[(t+4)/4],m=s[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,a,l,m),this.geometry.attributes.color.setXYZ(this.index++,i,n,r);const c=s[(e+0)/4],h=s[(e+4)/4],d=s[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,c,h,d),this.geometry.attributes.color.setXYZ(this.index++,i,n,r)}drawContactPoint(t,e,o,s,i){const n=Ammo.HEAPF32,r=n[(i+0)/4],a=n[(i+4)/4],l=n[(i+8)/4],m=n[(t+0)/4],c=n[(t+4)/4],h=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,m,c,h),this.geometry.attributes.color.setXYZ(this.index++,r,a,l);const d=n[(e+0)/4]*o,u=n[(e+4)/4]*o,p=n[(e+8)/4]*o;this.geometry.attributes.position.setXYZ(this.index,m+d,c+u,h+p),this.geometry.attributes.color.setXYZ(this.index++,r,a,l)}reportErrorWarning(t){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(t)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(t,e){console.warn("TODO: draw3dText")}setDebugMode(t){this.debugDrawMode=t}getDebugMode(){return this.debugDrawMode}}(this.scene,this.physicsWorld,{}))}updateDebugger(){"headless"!==this.scene&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:e=!1}=this.config;let o;if(!e){const t=new Ammo.btDefaultCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),s=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver;o=new Ammo.btDiscreteDynamicsWorld(e,s,i,t)}if(e){const t=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,e=new Ammo.btCollisionDispatcher(t),s=new Ammo.btDbvtBroadphase,i=new Ammo.btSequentialImpulseConstraintSolver,n=new Ammo.btDefaultSoftBodySolver;o=new Ammo.btSoftRigidDynamicsWorld(e,s,i,t,n)}return o.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),o}createDebrisFromBreakableObject(t,e){"headless"!==this.scene&&(t.material=this.defaultMaterial.get(),t.shape="hull",t.fragmentDepth=e.fragmentDepth+1,this.scene.add(t),this.addExisting(t),t.body.breakable=!1,setTimeout((()=>{t.body.breakable=!0}),2500))}removeDebris(t){"headless"!==this.scene&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const e=t/1e3;this.physicsWorld.stepSimulation(e,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let t=0;t<this.rigidBodies.length;t++){const e=this.rigidBodies[t],o=e.body.ammo.getMotionState();if(o)if(o.getWorldTransform(this.worldTransform),e.body.didUpdate&&(e.body._emitUpdateEvents&&e.body.eventEmitter.emit("update"),e.body.didUpdate=!1),e.body.ammo.isKinematicObject()&&e.body.needUpdate)e.getWorldQuaternion(this.tmpQuaternion),e.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),o.setWorldTransform(this.worldTransform),e.body.needUpdate=!1;else if(e.body.skipUpdate);else if(!e.body.ammo.isStaticObject()){let t=this.worldTransform.getOrigin(),o=this.worldTransform.getRotation(),s=e.body.offset;if(e.body.ignoreScale)this.tmpVector3a.set(e.scale.x,e.scale.y,e.scale.z);else{const t=e.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(t.x(),t.y(),t.z())}this.tmpVector3.set(t.x()+s.x,t.y()+s.y,t.z()+s.z),this.tmpQuaternion.set(o.x(),o.y(),o.z(),o.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),e.parent?parseInt(m.REVISION)>=123?this.tmpMatrix4a.copy(e.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(e.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(e.position,e.quaternion,e.scale)}}}detectCollisions(){var t,e;const o=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const s=this.physicsWorld.getDispatcher(),i=s.getNumManifolds();for(let n=0;n<i;n++){let i=s.getManifoldByIndexInternal(n),r=i.getNumContacts();const a=Ammo.castObject(i.getBody0(),Ammo.btRigidBody),l=Ammo.castObject(i.getBody1(),Ammo.btRigidBody);let m=a.threeObject,c=l.threeObject;if(!m||!c)continue;if(""===a.name&&""===l.name)continue;const h=null===(t=m.body)||void 0===t?void 0:t.checkCollisions,d=null===(e=c.body)||void 0===e?void 0:e.checkCollisions,u=m.body.breakable,p=c.body.breakable,y=u||p;if(!h&&!d&&!y)continue;let b=!1,g=0,f="start";for(let t=0;t<r;t++){const e=i.getContactPoint(t);if(e.getDistance()<=0){b=!0;const t=e.getAppliedImpulse(),s=e.get_m_positionWorldOnB(),i=e.get_m_normalWorldOnB();if(h||d){const t=[m.name,c.name].sort(),e=`${t[0]}__${t[1]}`;this.earlierDetectedCollisions.find((t=>t.combinedName===e))&&(f="collision"),o.find((t=>t.combinedName===e))||(o.push({combinedName:e,collision:!0}),this.collisionEvents.emit("collision",{bodies:[m,c],event:f}))}t>=g&&(g=t,(u||p)&&(this.impactPoint.set(s.x(),s.y(),s.z()),this.impactNormal.set(i.x(),i.y(),i.z())));break}}if(!b)continue;if(!y)continue;const w=5,v=2;if(this.emptyV3.set(0,0,0),m.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:u,physicsBody:a},c.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:p,physicsBody:l},void 0===m.fragmentDepth&&(m.fragmentDepth=0),void 0===c.fragmentDepth&&(c.fragmentDepth=0),u&&g>w&&m.fragmentDepth<v){const t=this.convexBreaker.subdivideByImpact(m,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let o=0;o<e;o++){const e=a.getLinearVelocity(),s=a.getAngularVelocity(),i=t[o];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(s.x(),s.y(),s.z()),this.createDebrisFromBreakableObject(i,m)}this.objectsToRemove[this.numObjectsToRemove++]=m}if(p&&g>w&&c.fragmentDepth<v){const t=this.convexBreaker.subdivideByImpact(c,this.impactPoint,this.impactNormal,1,2),e=t.length;for(let o=0;o<e;o++){const e=l.getLinearVelocity(),s=l.getAngularVelocity(),i=t[o];i.userData.ammoPhysicsData.velocity.set(e.x(),e.y(),e.z()),i.userData.ammoPhysicsData.angularVelocity.set(s.x(),s.y(),s.z()),this.createDebrisFromBreakableObject(i,c)}this.objectsToRemove[this.numObjectsToRemove++]=c}}for(let t=0;t<this.numObjectsToRemove;t++)this.removeDebris(this.objectsToRemove[t]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach((t=>{const{combinedName:e}=t;if(!o.find((t=>t.combinedName===e))){const t=e.split("__"),o=this.rigidBodies.find((e=>e.name===t[0])),s=this.rigidBodies.find((e=>e.name===t[1])),i="end";o&&s&&this.collisionEvents.emit("collision",{bodies:[o,s],event:i})}})),this.earlierDetectedCollisions=[...o]}setGravity(t=0,e=-9.8,o=0){this.tmpBtVector3.setValue(t,e,o),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){"undefined"!=typeof Ammo?"function"==typeof Ammo?Ammo().then((()=>{this.setup()})):this.setup():(0,t.default)("Are you sure you included ammo.js?")}get add(){return{collider:(t,e,o)=>this.collisionEvents.addCollider(t,e,o),constraints:this.constraints.addConstraints,existing:(t,e)=>this.addExisting(t,e),plane:(t={},e={})=>this.shapes.addPlane(t,e),sphere:(t={},e={})=>this.shapes.addSphere(t,e),ground:(t={},e={})=>this.shapes.addGround(t,e),box:(t={},e={})=>this.shapes.addBox(t,e),cylinder:(t={},e={})=>this.shapes.addCylinder(t,e),cone:(t={},e={})=>this.shapes.addCone(t,e),torus:(t={},e={})=>this.shapes.addTorus(t,e),extrude:(t,e={})=>this.shapes.addExtrude(t,e),raycaster:(t="closest")=>"closest"===t?new j(this):new E(this)}}prepareThreeObjectForCollisionShape(e,o={}){var s,i;const{autoCenter:n=!1}=o,r={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let a="unknown";const l=(null===(s=e.geometry)||void 0===s?void 0:s.type)||"unknown";/box/i.test(l)?a="box":/cone/i.test(l)?a="cone":/cylinder/i.test(l)?a="cylinder":/extrude/i.test(l)?a="extrude":/plane/i.test(l)?a="plane":/sphere/i.test(l)?a="sphere":/torus/i.test(l)&&(a="torus");let m=Object.assign(Object.assign({},r),null===(i=null==e?void 0:e.geometry)||void 0===i?void 0:i.parameters);return o.shape?(m=Object.assign(Object.assign({},r),o),a=o.shape):e.shape&&(a=e.shape),Object.keys(m).forEach((t=>{void 0===m[t]&&r[t]&&(m[t]=r[t])})),n&&e.geometry.center(),"cylinder"===a&&(m.radius=o.radius||m.radiusTop),"extrude"===a&&(a="hacd"),"mesh"!==a&&"convex"!==a||(a="convexMesh"),"concave"===a&&(a="concaveMesh"),"unknown"===a&&((0,t.default)(`Shape for ${null==e?void 0:e.name} not recognized! Will fallback to box.`),a="box"),{shape:a,params:m,object:e}}createCollisionShape(t,e,o){const s=(null==o?void 0:o.quaternion)?null==o?void 0:o.quaternion:new m.Quaternion(0,0,0,1),{axis:i="y"}=e,n=new Ammo.btVector3,r=null==o?void 0:o.geometry;o&&(null==r?void 0:r.isGeometry)&&(o.geometry=(new m.BufferGeometry).fromGeometry(r));let a,l={};switch(-1!==this.complexShapes.indexOf(t)&&(l=(t=>{const e=(new m.Matrix4).elements,o=[],s=[],i=[];return f(t,{},((t,e,n)=>{o.push(t),s.push(e),i.push(n)})),{vertices:o,matrices:s,indexes:i,matrixWorld:e}})(o)),t){case"box":n.setValue(e.width/2,e.height/2,e.depth/2),a=new Ammo.btBoxShape(n);break;case"sphere":a=new Ammo.btSphereShape(e.radius);break;case"cylinder":switch(i){case"y":n.setValue(e.radius,e.height/2,e.radius),a=new Ammo.btCylinderShape(n);break;case"x":n.setValue(e.height/2,e.radius,e.radius),a=new Ammo.btCylinderShapeX(n);break;case"z":n.setValue(e.radius,e.radius,e.height/2),a=new Ammo.btCylinderShapeZ(n)}break;case"cone":switch(i){case"y":a=new Ammo.btConeShape(e.radius,e.height);break;case"x":a=new Ammo.btConeShapeX(e.radius,e.height);break;case"z":a=new Ammo.btConeShapeZ(e.radius,e.height)}break;case"capsule":switch(i){case"y":a=new Ammo.btCapsuleShape(e.radius,e.height);break;case"x":a=new Ammo.btCapsuleShapeX(e.radius,e.height);break;case"z":a=new Ammo.btCapsuleShapeZ(e.radius,e.height)}break;case"torus":a=((t,e)=>{const{radius:o=1,tube:s=.4,tubularSegments:i=8}=t,n=Math.PI,r=i,a=Math.sqrt(2*s*s-2*s*s*Math.cos(2*n/r)),l=new Ammo.btVector3(s,n/r+.5*a,s),m=new Ammo.btCylinderShape(l);m.setMargin(.05);const c=new Ammo.btCompoundShape,h=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,o,0),u=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let t=0;t<r;t++){const e=2*t*n/r,o=d.rotate(h,e),s=new Ammo.btTransform;u.setRotation(h,e+Math.PI/2),s.setIdentity(),s.setOrigin(o),s.setRotation(u),c.addChildShape(s,m)}return c})(e,s);break;case"plane":a=y(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"hull":a=d(l.vertices,l.matrices,l.matrixWorld,e);break;case"hacd":a=u(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"vhacd":a=p(l.vertices,l.matrices,l.indexes,l.matrixWorld,e);break;case"convexMesh":a=y(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!1}));break;case"concaveMesh":a=y(l.vertices,l.matrices,l.indexes,l.matrixWorld,Object.assign(Object.assign({},e),{concave:!0}))}Ammo.destroy(n);const{x:c,y:h,z:b}=e;return(c||h||b)&&(a.offset={x:c||0,y:h||0,z:b||0}),Array.isArray(a)&&(a=this.mergeCollisionShapesToCompoundShape(a)),a}mergeCollisionShapesToCompoundShape(t){const e=new Ammo.btCompoundShape;return t.forEach((t=>{const{offset:o}=t,s=new Ammo.btTransform;s.setIdentity(),o&&s.getOrigin().setValue(o.x||0,o.y||0,o.z||0),e.addChildShape(s,t)})),e}addExisting(t,e={}){const{hasBody:o}=t;if(o)return void console.warn(`[Enable3d]: Object "${t.name}" already has a physical body!`);const s=new m.Vector3,i=new m.Quaternion,n=new m.Vector3;t.getWorldPosition(s),t.getWorldQuaternion(i),t.getWorldScale(n);const r="1"===(e.collisionFlags||0).toString(2).slice(-1),a="1"===(e.collisionFlags||0).toString(2).slice(-2,-1),{shape:l="unknown",compound:c=[],mass:h=(r||a?0:1),collisionFlags:d=0,collisionGroup:u=1,collisionMask:p=-1,offset:y,breakable:b=!1,addChildren:g=!0,margin:f=.01,ignoreScale:w=!1}=e;if(w&&n.set(1,1,1),c.length>=1){const e=c.map((t=>this.createCollisionShape(t.shape,t))),o=this.mergeCollisionShapesToCompoundShape(e),r=this.finishCollisionShape(o,s,i,n,f),l=this.collisionShapeToRigidBody(o,r,h,a);return this.addRigidBodyToWorld(t,l,d,u,p,b,y),void(t.body.ignoreScale=w)}const v=[];if("unknown"!==l||t.isMesh){const o=this.prepareThreeObjectForCollisionShape(t,e),s=this.createCollisionShape(o.shape,o.params,o.object);v.push(s)}if("unknown"===l&&g&&t.children.length>=1&&t.children.forEach((t=>{if(t.isMesh){const e=this.prepareThreeObjectForCollisionShape(t),o=this.createCollisionShape(e.shape,e.params,e.object);o.offset=t.position.clone(),v.push(o)}})),0===v.length){const o=this.prepareThreeObjectForCollisionShape(t,e),s=this.createCollisionShape(o.shape,o.params,o.object);v.push(s)}const x=1===v.length?v[0]:this.mergeCollisionShapesToCompoundShape(v),A=this.finishCollisionShape(x,s,i,n,f),V=this.collisionShapeToRigidBody(x,A,h,a);this.addRigidBodyToWorld(t,V,d,u,p,b,y),t.body.ignoreScale=w}addRigidBodyToWorld(t,o,s,i,n,r,a){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(o,i,n);const l=Object.values(o)[0];o.name=t.name,t.body=new e.Z(this,o),t.hasBody=!0,t.ptr=l,o.threeObject=t,r&&(t.body.breakable=!0),a&&(t.body.offset=Object.assign({x:0,y:0,z:0},a)),t.body.setCollisionFlags(s)}finishCollisionShape(t,e,o,s,i){t.setMargin(i);const n=new Ammo.btQuaternion(0,0,0,1);n.setValue(o.x,o.y,o.z,o.w);const r=new Ammo.btTransform;r.setIdentity(),r.getOrigin().setValue(e.x,e.y,e.z),r.setRotation(n),Ammo.destroy(n);const a=new Ammo.btVector3(s.x,s.y,s.z);return t.setLocalScaling(a),Ammo.destroy(a),r}collisionShapeToRigidBody(t,e,o,s){const i=new Ammo.btDefaultMotionState(e),n=new Ammo.btVector3(0,0,0);o>0&&t.calculateLocalInertia(o,n);const r=new Ammo.btRigidBodyConstructionInfo(o,i,t,n),a=new Ammo.btRigidBody(r);return(o>0||s)&&a.setActivationState(4),a}}})(),i})()}));
//# sourceMappingURL=enable3d.ammoPhysics.0.22.0-dev.0.min.js.map